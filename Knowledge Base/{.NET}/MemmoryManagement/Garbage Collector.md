У .NET використовується _генераційний_ (generational) підхід до збирання сміття (Garbage Collection, GC). Він базується на емпіричному спостереженні, що більшість об’єктів у програмі «живуть» недовго: створюються та швидко стають непотрібними. Щоб ефективно працювати з такими об’єктами, CLR використовує розділення керованого (managed) heaps на кілька генерацій: **Generation 0**, **Generation 1** та **Generation 2** (часто додають і поняття **Large Object Heap (LOH)** для великих об’єктів). Нижче наведено глибший розгляд принципів та механізмів роботи з генераціями на рівні Advanced.

---

## 1. Базові принципи «короткоживучих» та «довгоживучих» об’єктів

1. **Generation 0 (Gen0)**:
    
    - Найменший обсяг пам’яті, відведений під нові об’єкти.
    - Призначена для розміщення об’єктів, які мають короткий життєвий цикл.
    - Збирання Gen0 відбувається часто, але дуже швидко, адже обсяг даних тут відносно малий.
    - Якщо об’єкт виживає після GC Gen0, він _просувається_ (promotion) у Generation 1.
2. **Generation 1 (Gen1)**:
    
    - Проміжна генерація між «дуже короткоживучими» та «довгоживучими» об’єктами.
    - Якщо об’єкти у Gen1 знову переживають збірку, вони переходять у Generation 2.
    - Збірка Gen1 трохи менш часта, ніж Gen0, але все ще відносно швидка, бо об’єм об’єктів теж помірний.
3. **Generation 2 (Gen2)**:
    
    - Призначена в основному для об’єктів з тривалішим життєвим циклом.
    - Збірка Gen2 відбувається найрідше, бо припускається, що об’єкти, які вже двічі пережили GC (у Gen0 та Gen1), будуть доволі «довгоживучими».
    - Якщо виконується GC для Gen2, то фактично це «повна» збірка (Full GC). Вона, зазвичай, найдовша.
4. **Large Object Heap (LOH)**:
    
    - Містить великі об’єкти (від 85 KB і більше).
    - За замовчуванням збирається разом із Gen2 під час Full GC, але є винятки у більш пізніх версіях .NET (починаючи з .NET 4.5 та .NET Core), де можна вмикати _background sweeping_ для LOH.

---

## 2. Ефемерні сегменти (Ephemeral Segment) та «епізодичні» збирання

### Що таке ефемерний сегмент?

- **Ефемерний сегмент** — це виділений ділянка пам’яті (сегмент у керованому heap), який використовується для об’єктів Generation 0 та Generation 1.
- CLR намагається розмістити Gen0 та Gen1 фізично поруч, оскільки ці генерації часто збираються «одним махом» (епізодично).
- Завдяки цьому при зборі Gen0 «зачіпають» і Gen1, якщо простий GC Gen0 не дав бажаного результату або якщо за визначеними порогами (thresholds) виникає потреба збирати й Gen1.

### Епізодичне (ephemeral) збирання

- Коли збирання GC орієнтоване лише на Gen0/Gen1, його часто називають _ephemeral GC_.
- Такі збори мають відносно низьку вартість (менше зупинок і блокувань), оскільки обсяги Gen0 та Gen1 малі.
- Порівняно з повним GC (Gen2 + LOH), ephemeral GC мінімально впливає на продуктивність і, як правило, може виконуватися достатньо часто без серйозних просідань.

---

## 3. Спрацьовування та механізми promotion

### Коли відбувається GC?

Основні тригери (умовно спрощено):

1. **Переповнення Generation 0**: коли Gen0 заповнюється новоствореними об’єктами й немає місця для розміщення чергового об’єкта.
2. **System.GC.Collect()** викликається вручну (небажано в продакшені без гострої потреби).
3. **Системна пам’ять на межі** (особливо коли не вистачає фізичної пам’яті).
4. **Ряд внутрішніх евристик CLR** (фоновий моніторинг, великі алокації на LOH, тощо).

### Promotion: перехід об’єктів у старші генерації

- Об’єкт, що _виживає_ під час збирання Gen0 (тобто ще є на нього посилання), переміщується у Gen1.
- Аналогічно, якщо об’єкт виживає під час збирання Gen1, він переходить у Gen2.
- На рівні пам’яті це означає, що зріз «активних» об’єктів копіюється у нову область (як правило, для Gen0 і Gen1 використовується **copying collector**). Для Gen2 залежно від версії .NET можливі різні підходи (Workstation/Server, Background GC, SustainedLowLatency тощо).

---

## 4. Типи GC: Workstation, Server, Background

У більшості актуальних версій .NET доступні кілька режимів GC:

1. **Workstation GC**
    
    - Оптимізований для середовищ, де застосунок виконується на клієнтській машині (наприклад, десктоп).
    - Застосовується одне (або менше) ядро для збирання сміття.
2. **Server GC**
    
    - Оптимізований для сценаріїв з великою кількістю ядер і великими обсягами оперативної пам’яті (сервери, високонавантажені сервіси).
    - Збірка відбувається паралельно на декількох ядрах, кожне ядро має свій сегмент heap, і GC може блокувати всі потоки, аби виконати паралельну збірку.
    - Дає кращу продуктивність у багатоядерних середовищах, але збільшений загальний обсяг пам’яті.
3. **Background GC** (фоновий збирач)
    
    - З’явився, щоб уникнути тривалих «заморозок» додатка під час повного GC.
    - При фоновому GC Gen2 збирається асинхронно у фоновому потоці, тоді як ephemeral GC для Gen0/Gen1 продовжують виконуватися у «коротких» паузах.
    - Це дозволяє «розтягнути» full GC у часі та зменшити великі стоп-и загальної роботи застосунку.

---

## 5. Налаштування поведінки GC та вдосконалені аспекти

4. **Server vs. Workstation**
    
    - Керується конфігураційним файлом (.config) або змінними середовища, а також встановленням параметрів у csproj, наприклад:
        
        ```xml
        <PropertyGroup>
          <ServerGarbageCollection>true</ServerGarbageCollection>
        </PropertyGroup>
        ```
        
5. **SustainedLowLatency / LowLatency режими**
    
    - Дозволяють тимчасово мінімізувати повні збори (Gen2 / LOH) під час критичних для продуктивності операцій (наприклад, під час аудіо/відео рендерингу, реального часу обробки даних тощо).
    - При цьому, Gen0/Gen1 все одно збираються нормально, але GC максимально відкладає Gen2.
6. **Large Object Heap Compaction**
    
    - У новіших версіях .NET можна вмикати компактність LOH (зливання фрагментованих вільних просторів) під час Full GC.
    - За промовчанням LOH не компактується, щоб уникнути тривалих копійовань великих блоків пам’яті, але інколи фрагментація може призводити до суттєвих проблем і тоді це виправдано.
7. **Pinned Objects та “LOH Pinning”**
    
    - Часте використання об’єктів зі зв’язаними посиланнями на незмінні адреси може ускладнити роботу збирача сміття.
    - Pinned-об’єкти не копіюються, тож GC змушений обходити їх, що призводить до гіршої фрагментації та просідань.
8. **Probing та діагностика**
    
    - У випадку складних сценаріїв є можливості використати **Performance Counters**, **ETW events** (Event Tracing for Windows), **dotnet-counters** (у .NET Core і .NET 5+), **dotnet-trace**, а також профайлерів (наприклад, PerfView, dotTrace, JetBrains Rider, Visual Studio Diagnostics) для моніторингу GC-подій і розуміння його детальної поведінки.

---

## 6. Чому генераційний підхід ефективний?

9. **Принцип «більшість об’єктів недовговічні»**: Завдяки малому розміру Gen0 швидко очищується від «зайвих» об’єктів з мінімальною втратою продуктивності.
10. **Мінімізація переміщень «старих» об’єктів**: Якщо об’єкт справді «довгоживучий», він швидко перейде в Gen2 і більше не буде часто перевірятися.
11. **Спрямовані оптимізації**: .NET підтримує різні режими GC, які дають змогу налаштувати баланс між пропускною здатністю (throughput), затримками (latency) та споживанням пам’яті.

---

## Висновок

Генераційний механізм збирача .NET (з виділенням Gen0, Gen1, Gen2 і LOH) — один із ключових чинників високої продуктивності та гнучкості середовища CLR. Завдяки тому, що найчастіше збираються _ефемерні_ генерації (Gen0 і Gen1), застосунки можуть без наявних значних затримок очищати купу від короткоживучих об’єктів, а менш часте повне (Full) збирання мінімізує вплив на довгоживучі об’єкти.

На «advanced» рівні важливо знати про:

- Тонкощі роботи з **ефемерними сегментами** та механізмом promotion.
- Відмінності _server/workstation_, _foreground/background_ GC.
- Спеціальні режими (LowLatency, SustainedLowLatency), _compacting LOH_, а також діагностичні інструменти.

Усе це дозволяє точно налаштовувати збирач сміття під конкретний сценарій використання — від застосунків реального часу до розподілених систем із високими вимогами до пропускної здатності.