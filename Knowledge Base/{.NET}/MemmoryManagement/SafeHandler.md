У .NET `SafeHandle` — це спеціалізований _абстрактний_ клас (простір імен `System.Runtime.InteropServices`) для безпечного управління _unmanaged_ дескрипторами (handles), такими як файлові, мережеві, системні тощо. Основна мета `SafeHandle` — знизити ризики витоків ресурсів та проблем із пам’яттю, спростити роботу з фіналізаторами, а також надати механізм детермінованого та безпечного звільнення «native» ресурсів, мінімізуючи негативний вплив на збирач сміття (GC).

Нижче детально розглянемо, як працює `SafeHandle`, коли й навіщо ним користуватись, а також порівняємо з класичним підходом на базі «сирого» деструктора.

---

## 1. Проблеми «сирих» деструкторів (finalizers) з unmanaged дескрипторами

1. **Витоки при неправильному написанні деструктора**
    - Якщо розробник забув викликати `Dispose()` або невдало реалізував код фіналізації, дескриптор може не звільнитися коректно.
2. **Подвійна вартість GC**
    - Об’єкт із деструктором (finalizer) завжди «живе» принаймні два GC-цикли, оскільки не звільняється під час першого обігу. Це збільшує навантаження на Gen2 і потенційно спричинює додаткові Full GC.
3. **Непередбачувана в часі фіналізація**
    - Звільнення ресурсів переноситься на момент, коли спрацює фіналізатор у finalizer thread, що відбувається _недетерміновано_.
4. **Складність та ризик помилок**
    - Реалізація деструкторів із необережним доступом до керованих об’єктів, блокуваннями, повторною ініціалізацією тощо, може бути джерелом додаткових проблем.

---

## 2. Що таке SafeHandle?

`SafeHandle` — це базовий клас, покликаний спростити управління «рідними» (native) дескрипторами/хендлами. Він реалізує:

- **Фіналізатор**, який грамотно узгоджений із GC.
- **Метод Dispose**, що викликає `ReleaseHandle()` (абстрактний метод).
- **Код, який забезпечує «натягування» (marshalling) handle’ів**, аби вони безпечно передавалися між керованим (managed) і некерованим (unmanaged) кодом.
- **SafeHandle несе всередині _IntPtr handle_** і вбудовані логіку та прапорці: чи handle дійсний, чи вже звільнений, чи фіналізується тощо.

### Ключова ідея:

Ваш клас, замість визначення власного деструктора (де вручну викликається якась `CloseHandle()`), створює похідний тип від `SafeHandle` (або використовує вже готові реалізації — наприклад, `Microsoft.Win32.SafeHandles`), який виконує очищення handle правильно й без додаткових зусиль з вашого боку.

#### Приклад (спрощений):

```csharp
using Microsoft.Win32.SafeHandles;
using System;
using System.Runtime.InteropServices;

public sealed class SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid
{
    public SafeFileHandle() : base(true) // 'true' => власник handle’у (CanRelease).
    {
    }

    protected override bool ReleaseHandle()
    {
        return CloseHandle(handle);
    }

    [DllImport("kernel32", SetLastError = true)]
    private static extern bool CloseHandle(IntPtr handle);
}
```

Замість унікального деструктора в кожному класі, реалізація `ReleaseHandle()` лаконічно каже, як саме звільнити handle.

---

## 3. Переваги SafeHandle

1. **Усунення потреби в написанні «сирого» деструктора**
    
    - Оскільки основна функція з очистки handle-у переноситься у `SafeHandle`, клас-клієнт може просто реалізувати `IDisposable` без фіналізатора або й взагалі не мати потреби в `Dispose()`, якщо сам цей клас є суто обгорткою `SafeHandle`.
2. **Менший ризик «витоку» ресурсів**
    
    - `SafeHandle` гарантує, що коли GC знайде handle без посилань, він викличе внутрішній фіналізатор `SafeHandle`, який виконає `ReleaseHandle()`.
    - Також `SafeHandle` використовує _CriticalFinalizerObject_, що означає, що навіть у разі непередбачених винятків .NET _гарантує_, що фіналізатор `SafeHandle` буде відпрацьований, щоб не призвести до катастрофічних витоків.
3. **Детерміноване звільнення**
    
    - Можна викликати `Dispose()` (або використовувати `using`) на самому `SafeHandle` чи на класі, що ним володіє. Тоді handle звільняється відразу, без очікування GC.
4. **Атомарність зміни стану handle**
    
    - `SafeHandle` усіма можливими засобами намагається уникнути ситуацій «подвійного звільнення» чи «спроби звільнити вже недійсний handle» завдяки внутрішнім прапорцям та методам `SetHandleAsInvalid()`, `IsClosed`, `IsInvalid`.
5. **Покращена підтримка P/Invoke**
    
    - Коли метод із native-бібліотеки приймає/повертає handle, використовувати `SafeHandle` часто безпечніше, ніж звичайний `IntPtr`.

---

## 4. Використання SafeHandle у Dispose-патерні

Найчастіше `SafeHandle` інтегрується в клас, що слідує шаблону Disposable (IDisposable).  
Загальний принцип:

```csharp
using Microsoft.Win32.SafeHandles;
using System.Runtime.InteropServices;

public class MyResourceWrapper : IDisposable
{
    private SafeFileHandle _handle;
    
    public MyResourceWrapper(string fileName)
    {
        // Припустимо, викликаємо WinAPI, що повертає файловий хендл
        _handle = CreateFile(...); 
        if (_handle.IsInvalid)
        {
            // throw ...
        }
    }

    // Рекомендований підхід - без деструктора, оскільки SafeHandle сам має вбудований деструктор.
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this); // Якщо раптом деструктор все ж існує
    }

    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            // Звільняємо керовані ресурси, якщо є
        }

        // Звільняємо handle
        if (_handle != null && !_handle.IsClosed)
        {
            _handle.Dispose();
            _handle = null;
        }
    }

    [DllImport("kernel32", SetLastError = true)]
    private static extern SafeFileHandle CreateFile(...);
}
```

### Основні моменти:

- Клас `MyResourceWrapper` **не має** власного деструктора.
- Якщо з будь-яких причин користувач не викличе `Dispose()`, `SafeFileHandle` усе одно підхопиться GC та звільнить native-хендл у своєму фіналізаторі.
- В ідеалі ми хочемо детерміноване звільнення, тому зазвичай користуємося `using var myResource = new MyResourceWrapper("foo.txt");`.

---

## 5. Вбудовані реалізації SafeHandle

У просторі імен `Microsoft.Win32.SafeHandles` є декілька вже готових реалізацій для поширених ресурсів:

- `SafeFileHandle`
- `SafeWaitHandle`
- `SafeRegistryHandle`
- тощо.

Якщо у вас handle типу «дескриптор файлу» на Windows, варто використовувати `SafeFileHandle` (під капотом воно реалізовано точно тим самим способом, описаним вище).

Якщо необхідно взаємодіяти з чимось більш специфічним, не охопленим стандартними класами, ви можете успадковуватися від `SafeHandle` чи `CriticalHandle` і перевизначити `ReleaseHandle()`.

---

## 6. Performance та інші аспекти

6. **Менший тиск на Gen2**
    
    - Хоча `SafeHandle` усе одно має фіналізатор, це зазвичай _ефективніша_ й _безпечніша_ абстракція, ніж деструктор у кожному класі, який управляє unmanaged-ресурсами.
    - Завдяки централізованій реалізації у фреймворку вдалося оптимізувати цю фіналізацію так, щоб знижувати вірогідність довгих GC-пауз і збирати ресурси передбачуваніше.
7. **CriticalFinalizerObject**
    
    - `SafeHandle` успадковується від `CriticalFinalizerObject`. Це означає, що _навіть_ якщо під час фіналізації стаються винятки, інші finalizer’и або «асинхронні» зупинки процесу, runtime робить усе, щоб `ReleaseHandle()` гарантувано було викликано (за умови, що процес триває і не трапився, наприклад, «повний крах»).
    - Це серйозна перевага, бо убезпечує від катастрофічних витоків дескрипторів, які могли б залишитися «відкритими».
8. **Логіка «двоступеневої» ідентифікації**
    
    - `SafeHandle` має дві властивості: `IsInvalid` (чи handle взагалі валідний) і `IsClosed` (чи вже викликали `Dispose()`). Таким чином, навіть якщо handle отриманий, але системний виклик повернув «-1» чи `INVALID_HANDLE_VALUE`, `IsInvalid` = `true`.
    - «Закритий» (`IsClosed`) може означати, що користувач викликав `Dispose()` або ж фіналізатор уже відпрацював.

---

## 7. Резюме та рекомендації

9. **Використовуйте `SafeHandle` замість власного фіналізатора**
    
    - Якщо ваш об’єкт напряму керує «рідним» ресурсом (socket, file handle, system handle, тощо), створіть похідний клас від `SafeHandle` (або використайте наявний із `Microsoft.Win32.SafeHandles`), і в `ReleaseHandle()` викликайте належну функцію закриття.
10. **Залишайте `IDisposable`-клас простим**
    
    - У більшості випадків вам достатньо реалізувати `Dispose(bool disposing)`, що звільнить керовані об’єкти та викликає `SafeHandle.Dispose()`.
    - Не потрібен власний деструктор, адже `SafeHandle` має фіналізатор.
11. **Детерміноване звільнення**
    
    - Рекомендується завжди використовувати `using` (`await using`), щоб уникати надмірних GC-процесів і швидко очищати handle, коли він більше не потрібний.
12. **Діагностика**
    
    - Якщо підозрюєте витоки дескрипторів, профайлери на кшталт _PerfView_, _dotTrace_, _Visual Studio Diagnostics_ можуть показати об’єкти типу `SafeHandle`, що не були «збірні» GC. Налагодження зазвичай простіше, ніж у випадках з неправильними деструкторами.
13. **Враховуйте кросплатформеність**
    
    - У .NET 5+ і .NET 6+ `SafeHandle` сумісний між Windows/Linux/macOS, хоча конкретні реалізації (`SafeFileHandle`, `SafeMemoryMappedFileHandle` тощо) можуть відрізнятися. Це дає змогу писати портативний код із мінімальною «рідною» адаптацією.

---

## Підсумок

`SafeHandle` — ключовий інструмент для безпечного та ефективного управління «рідними» дескрипторами в середовищі .NET. Він закриває «дірки» класичного підходу, коли доводилось у кожному класі писати власний деструктор для handle’ів. Замість цього розробник одержує централізоване й оптимізоване рішення:

- **Захищений механізм фіналізації** (через `CriticalFinalizerObject`).
- **Детерміноване звільнення** за допомогою `Dispose()`.
- **Минимізація помилок** «подвійного звільнення» та «handle is invalid».
- **Краща керованість** з боку GC та прозора діагностика.

У більшості сценаріїв, пов’язаних із «нативними» ресурсами, вибір `SafeHandle` — це «best practice» у .NET, що дозволяє уникнути багатьох підводних каменів ручного деструктора та сприяє кращій продуктивності й надійності застосунків.