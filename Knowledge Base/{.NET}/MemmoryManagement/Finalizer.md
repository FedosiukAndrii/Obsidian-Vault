У .NET деструктор (finalizer) — це спеціальний метод (у C# записується через символ `~ClassName()`) для класу, що викликається _неявно_ збирачем сміття (GC) перед видаленням об’єкта з пам’яті. Механізм деструкторів дає змогу «добратися» до об’єкта, коли він уже став недоступним із коду, і виконати будь-які дії з очищення «нешарованих» або небезпечних (unmanaged) ресурсів. Втім, використання деструкторів слід розглядати дуже обережно, адже вони серйозно впливають на поведінку й продуктивність GC. Розгляньмо це детальніше на просунутому рівні.

---

## 1. Основна логіка та взаємодія з GC

1. **Виявлення об’єкта, придатного для фіналізації**
    
    - Під час збирання сміття, якщо GC бачить, що на об’єкт немає більше посилань, він перевіряє, чи має об’єкт деструктор.
    - Якщо деструктор є, об’єкт **не** звільняється одразу, а переміщується у внутрішню чергу фіналізації (finalization queue).
    - Це означає, що з погляду GC об’єкт «живий» доти, доки його деструктор не відпрацює.
2. **Фіналізація на окремому потоці**
    
    - У середовищі CLR існує спеціалізований _finalizer thread_, який періодично обробляє чергу фіналізації (finalization queue).
    - Коли потік доходить до об’єкта, викликається метод-деструктор `~ClassName()`.
    - Цей виклик _не_ гарантує порядку виконання щодо інших об’єктів чи інших потоків.
3. **Перехід до «freachable» черги**
    
    - Насправді об’єкт потрапляє спочатку у finalization queue (після того, як GC визначив його недоступним), потім, коли черга почне виконуватись, об’єкт переноситься в окрему чергу freachable (Finalization-Reachable).
    - Сам деструктор виконується у фіналізаторному потоці, після чого об’єкт остаточно вважається придатним до видалення.
4. **Наслідок для життєвого циклу: «Resurrection» (воскресіння)**
    
    - Теоретично, якщо в тілі деструктора якийсь глобальний (статичний) або інший «живий» об’єкт збереже посилання на `this`, об’єкт «воскресне». Це дуже небажана практика, здатна викликати заплутані побічні ефекти.
    - Фактично об’єкт стане знову доступним і не буде знищеним під час поточного GC. У наступних GC його знову треба буде збирати.

---

## 2. Чому фіналізатори «дорогі»?

1. **Затримка звільнення пам’яті**
    
    - Навіть коли об’єкт уже недоступний для коду, GC змушений утримувати його допоки не запуститься деструктор. Це подовжує «життя» об’єкта і збільшує споживання пам’яті.
2. **Додатковий етап збирання**
    
    - Після того, як викликано деструктор, об’єкт знову «помічається» GC для остаточного звільнення пам’яті (потрібен ще один GC-прохід). Тобто об’єкт, що має деструктор, вимагає _принаймні два GC-цикла_, аби повністю зникнути з купи.
3. **Непередбачуваність часу виклику**
    
    - Фіналізатор викликається _недетерміновано_ (коли GC вирішить, що треба). Тому покладатись на деструктор у сценаріях, де потрібна передбачувана й гарантована очистка (наприклад, звільнення файлів чи закриття з’єднань із БД) — **погана практика**.
    - «Час життя» фіналізаторів залежить від завантаженості системи, налаштувань GC і т. ін.
4. **Блокування фіналізаторного потоку**
    
    - Якщо всередині деструктора виконується важка операція (I/O, довгі обчислення), це може «підвісити» потік фіналізації на тривалий час. Унаслідок цього інші об’єкти, що очікують на фіналізацію, теж не будуть фіналізовані вчасно, викликаючи наростання використання пам’яті.

---

## 3. Коли фіналізатор дійсно виправданий?

### 3.1 Взаємодія з unmanaged ресурсами

Наявність фіналізатора зазвичай виправдовується тоді, коли клас **безпосередньо** керує зовнішніми або небезпечними ресурсами (native handles, сокети, файлові дескриптори, невивантажені бібліотеки), _і_ якщо немає можливості уникнути фіналізатора на користь вбудованих безпечних обгорток (на кшталт `SafeHandle`).

#### Приклад:

```csharp
public class NativeResourceHolder
{
    private IntPtr _nativeHandle; // Припустимо, що це handle на необмежений ресурс.

    public NativeResourceHolder()
    {
        // Виклик native-функції, повертає handle
        _nativeHandle = NativeMethods.AllocHandle(); 
    }

    ~NativeResourceHolder()
    {
        // Деструктор (finalizer) звільняє handle
        if (_nativeHandle != IntPtr.Zero)
        {
            NativeMethods.FreeHandle(_nativeHandle);
            _nativeHandle = IntPtr.Zero;
        }
    }
}
```

Але навіть у цьому випадку в сучасній .NET _рекомендовано_ використовувати шаблони на основі `SafeHandle`, де фіналізатор реалізовано глибше (у спеціалізованому типі), а ваш код звільнений від написання «низькорівневого» деструктора.

### 3.2 Реалізація `IDisposable`

Типово в .NET застосовують _шаблон_ [Dispose Pattern](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose) для сумісності з `using` або `await using`, щоб забезпечити **детерміноване** звільнення ресурсів.

- Як правило, патерн передбачає:
    1. Публічний метод `Dispose()` + приватне чи захищене `Dispose(bool disposing)`.
    2. Необов’язковий деструктор, який викликає `Dispose(false)` (звільнення unmanaged ресурсів без керованих).
    3. Скасовування фіналізатора викликом `GC.SuppressFinalize(this)` у методі `Dispose()`, якщо ресурси звільнено вручну вчасно.

Таким чином, якщо розробник чітко викликає `Dispose()`, ресурси звільняються одразу й деструктор не потрібен. Якщо розробник **забув** викликати `Dispose()`, тоді на сцену виходить деструктор як «аварійний захист».

---

## 4. Взаємодія з Generations

1. **Об’єкти з деструкторами складніше збирати**
    
    - На практиці об’єкти з фіналізаторами «протягуються» в старші генерації (Gen1, Gen2), бо під час першого проходу GC вони не можуть бути одразу звільнені.
    - Це збільшує тиск на Gen2 і може провокувати повні GC (Full GC) частіше.
2. **Background GC і фіналізація**
    
    - У режимах _background GC_ прибирання Gen2 може відбуватися у фоновому потоці, проте фіналізація все одно виконується в окремому спеціалізованому потокові (finalizer thread).
    - Погано написані деструктори з тривалими блокуючими операціями зменшують перевагу background GC, бо з’являються «затори» всередині фіналізатора.

---

## 5. Поради з оптимізації та діагностики

1. **Користуйтеся `SafeHandle` та іншими .NET-абстракціями**
    
    - `SafeHandle` реалізує внутрішній безпечний фіналізатор. Тоді ваш клас може просто використовувати `IDisposable`, а низькорівневу фіналізацію візьме на себе фреймворк.
2. **Вимикайте фіналізатор при ручному звільненні**
    
    - Якщо вже довелося писати деструктор, обов’язково викликайте `GC.SuppressFinalize(this)` у `Dispose()`, щоб уникнути дублювання звільнення.
3. **Уникайте важких операцій**
    
    - Деструктор має бути максимально легковаговим. Будь-які тривалі I/O чи блокування призведуть до затримок фіналізатора й надмірної алокації об’єктів, що чекають у черзі.
4. **Перевіряйте “Debug/Diag Tools”**
    
    - Для складних сценаріїв використовуйте _профайлери_ (PerfView, dotTrace, JetBrains Rider, Visual Studio Diagnostics). Звертайте увагу на тривалість finalization thread, кількість об’єктів у finalization queue, час між алокацією й очищенням.
5. **Мінімізуйте кількість класів із деструкторами**
    
    - Якщо клас не працює з unmanaged-ресурсами безпосередньо, йому **не потрібен** деструктор.
    - Більшість сценаріїв покриває `IDisposable` (або жодних фіналізаторів взагалі).

---

## Висновок

Фіналізатори (деструктори) у .NET відіграють допоміжну роль для безпечного звільнення unmanaged ресурсів, коли розробник не забезпечив детермінованого виклику `Dispose()`. Водночас вони ускладнюють роботу GC: об’єкт із деструктором «доживає» як мінімум дві збірки, збільшує тиск на Gen2, а сам фіналізатор виконується _недетерміновано_ в окремому потоці.

Через це у більшості випадків краще покладатися на:

- **Шаблон Dispose** (IDisposable) для керованого, передбачуваного звільнення ресурсів.
- **SafeHandle** або інші обгортки для unmanaged ресурсів, що вже мають оптимізовану реалізацію фіналізатора з боку фреймворку.

Якщо ж деструктор справді потрібен (дуже низькорівневі ресурси), варто робити його _простим і швидким_, обов’язково реалізуючи патерн Dispose + `GC.SuppressFinalize()` для усунення непотрібних викликів деструктора у випадку ручного звільнення.
