У .NET є велика кількість стандартних колекцій у просторі імен `System.Collections` та `System.Collections.Generic`, кожна з яких оптимізована для різних сценаріїв використання. Далі розглянемо їх на рівні **Advanced**, з фокусом на внутрішні механізми роботи, продуктивність і вибір оптимальної структури.

---

## 1. **Колекції на основі масивів**

### **1.1. List**

- Реалізований як **динамічний масив**.
- Використовує внутрішній `T[] array`, що **збільшується** у 2 рази, якщо не вистачає місця.
- Операції:
    - `Add(T item)` – O(1) в середньому, O(n) у найгіршому випадку (при перевиділенні пам’яті).
    - `Insert(int index, T item)` – O(n) через зсув елементів.
    - `RemoveAt(int index)` – O(n) через зсув елементів.
    - `Contains(T item)`, `IndexOf(T item)` – O(n) у загальному випадку, O(1) для `SortedList<T>`.
- Особливості:
    - Швидкий доступ по індексу `O(1)`.
    - Можливий оверхед при частому збільшенні розміру.

### **1.2. ArraySegment**

- Використовується для представлення підмасиву **без копіювання даних**.
- Вказує на певний відрізок масиву через **початковий індекс та довжину**.
- Використовується у високопродуктивних операціях (наприклад, в `Span<T>`).

---

## 2. **Зв’язні списки**

### **2.1. LinkedList**

- Двонаправлений список (`Doubly Linked List`).
- Ефективний для:
    - Додавання/видалення у **початок/кінець** O(1).
    - Додавання/видалення в **середину** при наявності посилання на вузол O(1).
- Недоліки:
    - Лінійний пошук `O(n)`, що робить його менш ефективним для частих пошуків.
    - Великий оверхед через зберігання `prev/next` посилань.

---

## 3. **Стек та черга**

### **3.1. Stack**

- Реалізація **LIFO (Last In First Out)** на базі `List<T>`.
- Операції:
    - `Push(T item)`, `Pop()` – O(1) (в середньому).
    - Використовується у рекурсії, парсерах, алгоритмах обходу графів (DFS).

### **3.2. Queue**

- Реалізація **FIFO (First In First Out)**.
- Реалізований як **кільцевий буфер** (circular array).
- `Enqueue(T item)`, `Dequeue()` – O(1).
- Корисний для **асинхронної обробки завдань**.

### **3.3. ConcurrentQueue**

- Потокобезпечний `Queue<T>` (без блокування).
- Використовує **lock-free** алгоритм на базі **Interlocked.CompareExchange**.

### **3.4. PriorityQueue<T, TPriority>**

- Черга з **пріоритетами** (min-heap).
- Операції:
    - `Enqueue(item, priority)` – O(log n).
    - `Dequeue()` – O(log n).

---

## 4. **Словники**

### **4.1. Dictionary<TKey, TValue>**

- Реалізований як **хеш-таблиця** (`HashTable`).
- Використовує **відкриту адресацію (`open addressing`)** через `Entry[]`.
- Операції:
    - `Add()`, `Remove()`, `TryGetValue()` – O(1) у середньому випадку, O(n) у найгіршому (колізії).
    - `ContainsKey()` – O(1).
- Використовує `IEqualityComparer<TKey>` для порівняння ключів.

### **4.2. SortedDictionary<TKey, TValue>**

- Реалізований на **червонo-чорному дереві (`Red-Black Tree`)**.
- Підтримує **сортування** ключів.
- `Add()`, `Remove()`, `ContainsKey()` – O(log n).

### **4.3. ConcurrentDictionary<TKey, TValue>**

- Потокобезпечний `Dictionary<TKey, TValue>`.
- Використовує **sharding** (поділ на секції) для зменшення блокувань.

---

## 5. **Множини**

### **5.1. HashSet**

- Використовує **хеш-таблицю** для унікальних значень.
- Операції `Add()`, `Contains()`, `Remove()` – O(1) у середньому випадку.

### **5.2. SortedSet**

- Реалізований як **червонo-чорне дерево**.
- `Add()`, `Remove()`, `Contains()` – O(log n).
- Зберігає елементи у **відсортованому вигляді**.

---

## 6. **Спеціалізовані колекції**

### **6.1. Immutable Collections**

- Колекції з `System.Collections.Immutable`.
- Гарантують **незмінність (`immutability`)**.
- Використовуються у **багатопотокових** середовищах.

### **6.2. BlockingCollection**

- Використовується для **паралельного програмування** (`Producer-Consumer` pattern).
- Заснована на `ConcurrentQueue<T>`.

### **6.3. BitArray**

- Ефективне представлення **масиву бітів**.
- Використовується для **оптимізації пам’яті** (наприклад, у `Bloom Filter`).

---

## **Підбір структури для задачі**

|Задача|Оптимальна колекція|Складність|
|---|---|---|
|Швидкий доступ за індексом|`List<T>`|O(1)|
|Часті вставки/видалення|`LinkedList<T>`|O(1)|
|Обробка стекових структур|`Stack<T>`|O(1)|
|Обробка черг|`Queue<T>`|O(1)|
|Підтримка черги з пріоритетами|`PriorityQueue<T, TPriority>`|O(log n)|
|Унікальні елементи|`HashSet<T>`|O(1)|
|Відсортовані унікальні елементи|`SortedSet<T>`|O(log n)|
|Швидкий пошук по ключу|`Dictionary<TKey, TValue>`|O(1)|
|Відсортований словник|`SortedDictionary<TKey, TValue>`|O(log n)|
|Багатопотоковість|`ConcurrentDictionary<TKey, TValue>`|O(1)|

---

## Висновок

Кожна стандартна колекція .NET має **свої переваги та обмеження**. Вибір залежить від вимог до продуктивності, потокобезпеки, пам’яті та операцій, що виконуються найчастіше.

Якщо потрібна **швидкість** → `List<T>`, `Dictionary<TKey, TValue>`, `HashSet<T>`.  
Якщо **сортування** → `SortedDictionary<TKey, TValue>`, `SortedSet<T>`.  
Якщо **багатопотоковість** → `ConcurrentDictionary<TKey, TValue>`, `ConcurrentQueue<T>`.