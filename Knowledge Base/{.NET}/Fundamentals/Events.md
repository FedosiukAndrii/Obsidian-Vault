**Події (Events) у .NET** – це механізм, який дозволяє об’єктам сповіщати інші об’єкти про те, що відбулася певна дія. Це дуже корисно в парадигмі розробки на основі подій (event-driven), де нам потрібно організувати взаємодію між компонентами, що реагують на зміни стану чи інші важливі дії.

У .NET реалізація механізму подій пов’язана з поняттям **делегатів (delegates)**, оскільки події – це, по суті, “відповідно оголошені делегати з додатковими обмеженнями”. Розгляньмо деталі.

---

## 1. Ключові концепції

### 1.1 Делегати (Delegates)

- **Делегат** – це тип, який описує сигнатуру (повертаємий тип і список параметрів) методів, що можуть бути викликані через нього.
- Простими словами, делегат дозволяє зберігати посилання на метод (чи кілька методів) і викликати їх пізніше, не знаючи конкретного імені методу, а лише його сигнатуру.

```csharp
public delegate void MyDelegate(string message);

public class TestClass
{
    public void SomeMethod(string message)
    {
        Console.WriteLine(message);
    }
}
```

### 1.2 Події (Events)

- **Подія** – це “сповіщення” про те, що щось сталося. У .NET події визначаються за допомогою ключового слова `event` і типу делегата.
- На подію можна підписатися, передаючи метод, який буде виконаний у момент виникнення цієї події.
- Приклад: якщо у вас є клас `Button`, він може оголошувати подію `Click`; інші об’єкти підписуються на `Click`, щоб отримувати сповіщення, коли користувач натисне кнопку.

```csharp
public delegate void ClickDelegate(object sender, EventArgs e);

public class Button
{
    public event ClickDelegate Click;

    protected virtual void OnClick()
    {
        // Перевіряємо, чи є підписники
        if (Click != null)
        {
            // Викликаємо делегат
            Click(this, EventArgs.Empty);
        }
    }

    public void SimulateClick()
    {
        OnClick();
    }
}
```

У прикладі вище:

1. Оголошується делегат `ClickDelegate`, який приймає об’єкт-відправник (`sender`) та аргументи події (`EventArgs e`).
2. У класі `Button` описується подія `Click` цього типу делегата.
3. Метод `OnClick` викликає подію `Click` (якщо є підписники).
4. Метод `SimulateClick` імітує натискання кнопки, викликаючи `OnClick()`.

### 1.3 Стандартні делегати .NET: `EventHandler` та `EventHandler<T>`

- У більшості випадків у .NET рекомендується використовувати базові делегати `EventHandler` і `EventHandler<T>` замість власних.
- `EventHandler` має сигнатуру:
    
    ```csharp
    public delegate void EventHandler(object sender, EventArgs e);
    ```
    
- `EventHandler<T>` – узагальнена (generic) версія, де `T` – клас, що наслідується від `EventArgs`:
    
    ```csharp
    public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e)
        where TEventArgs : EventArgs;
    ```
    

Приклад:

```csharp
public class MyEventArgs : EventArgs
{
    public string Message { get; set; }
}

public class MyPublisher
{
    public event EventHandler<MyEventArgs> SomethingHappened;

    protected virtual void OnSomethingHappened(string message)
    {
        SomethingHappened?.Invoke(this, new MyEventArgs { Message = message });
    }

    public void DoWork()
    {
        // Викликаємо подію
        OnSomethingHappened("Дія виконана");
    }
}
```

---

## 2. Як підписуватися та відписуватися (subscribe / unsubscribe)

Припустимо, у нас є `MyPublisher` з подією `SomethingHappened`, і ми хочемо реагувати на неї.

```csharp
public class MySubscriber
{
    public void HandleEvent(object sender, MyEventArgs e)
    {
        Console.WriteLine($"Отримано подію з повідомленням: {e.Message}");
    }
}

// Десь у коді...
MyPublisher publisher = new MyPublisher();
MySubscriber subscriber = new MySubscriber();

// Підписуємося
publisher.SomethingHappened += subscriber.HandleEvent;

// Викликаємо дію, що спричинить подію
publisher.DoWork();

// Відписуємося (якщо більше не потрібно слухати подію)
publisher.SomethingHappened -= subscriber.HandleEvent;
```

1. **Підписка** відбувається через `+=`.
2. **Відписка** відбувається через `-=`.  
    Варто вчасно відписуватися, особливо в довготривалих застосунках, щоб уникати витоків пам’яті (memory leaks), коли об’єкт вже не потрібен, але все ще підписаний на події.

---

## 3. Рекомендований підхід: Патерн “відправник-аргументи”

У .NET існує загальноприйнятий **патерн обробки подій**:

1. **Відправник** (`sender`) – об'єкт, що генерує подію.
2. **Аргументи** (`EventArgs`) – набір пов’язаних з подією даних. Якщо даних немає, використовують `EventArgs.Empty`.

Тому за можливості використовуйте:

```csharp
public event EventHandler<EventArgs> OnSomething;
```

або

```csharp
public event EventHandler<CustomEventArgs> OnSomethingHappened;
```

де `CustomEventArgs` успадковується від `EventArgs`.

---

## 4. Модифікатори доступу та методи ініціації подій

Водночас із ключовим словом `event` є **обмеження доступу** до виклику події. Тобто, **подію можуть викликати тільки методи зсередини класу**, у якому вона оголошена. Підписники можуть лише підписуватися чи відписуватися.

Зазвичай у класі, який оголошує подію, роблять “захищений віртуальний метод” (protected virtual method), котрий викликає подію:

```csharp
public class MyClass
{
    public event EventHandler<EventArgs> MyEvent;

    protected virtual void OnMyEvent()
    {
        MyEvent?.Invoke(this, EventArgs.Empty);
    }
}
```

Так ми можемо контролювати, коли саме викликається подія.

---

## 5. Асинхронна обробка подій

Події самі по собі викликаються синхронно: коли виникає подія, всі підписані методи викликаються в тому ж потоці. Якщо є потреба виконувати обробку події у фоновому потоці чи асинхронно, код всередині підписаного методу має сам розпаралелюватися (наприклад, через `Task.Run(...)` чи async/await).

---

## 6. Приклад використання

Наведемо простий приклад, що ілюструє повний цикл від визначення події до її обробки.

```csharp
using System;

public class TimerEventArgs : EventArgs
{
    public DateTime CurrentTime { get; set; }
}

public class SimpleTimer
{
    // Подія зі стандартним дженериковим делегатом
    public event EventHandler<TimerEventArgs> Tick;

    public void Start(int count)
    {
        for (int i = 1; i <= count; i++)
        {
            // Імітуємо якийсь процес
            System.Threading.Thread.Sleep(1000);

            // Викликаємо подію
            OnTick(DateTime.Now);
        }
    }

    protected virtual void OnTick(DateTime currentTime)
    {
        // Перевіряємо, чи є підписники
        Tick?.Invoke(this, new TimerEventArgs { CurrentTime = currentTime });
    }
}

// Клас-підписник
public class TimerSubscriber
{
    public void OnTimerTick(object sender, TimerEventArgs e)
    {
        Console.WriteLine($"Час: {e.CurrentTime.ToLongTimeString()}");
    }
}

class Program
{
    static void Main()
    {
        var timer = new SimpleTimer();
        var subscriber = new TimerSubscriber();

        // Підписуємося на подію
        timer.Tick += subscriber.OnTimerTick;

        // Запускаємо таймер (3 повторення)
        timer.Start(3);

        // По завершенні можна відписатися:
        timer.Tick -= subscriber.OnTimerTick;
    }
}
```

В результаті в консолі ми побачимо три повідомлення з поточним часом, що свідчитимуть про “спрацьовування” події `Tick`.

---

## 7. Поширені помилки та тонкощі

1. **Забувати перевіряти чи є підписники**  
    До появи скороченої форми `?.Invoke(...)` було поширеною практикою перевіряти подію на `null`:
    
    ```csharp
    if (MyEvent != null)
        MyEvent(this, EventArgs.Empty);
    ```
    
    Якщо не зробити перевірку, і жоден підписник не прослуховує подію, це призведе до `NullReferenceException`.
    
2. **Подвійна підписка**  
    Якщо двічі викликати `publisher.SomeEvent += subscriber.Handler`, метод буде викликатися двічі. Слідкуйте, щоб випадково не підписуватись двічі чи більше разів на одну й ту ж подію, якщо це не потрібно.
    
3. **Витоки пам’яті (memory leaks)**  
    Якщо об’єкт, який підписався на подію, довго не звільняється, а подія генерується часто, це може призвести до надмірного споживання ресурсів. Тому відписуйтесь від подій, коли об’єкт більше не потрібен.
    
4. **Використання анонімних методів / лямбд**  
    Коли підписуєтесь через лямбди, складніше відписуватися, якщо не зберегли посилання на ту ж лямбду. Наприклад:
    
    ```csharp
    publisher.SomeEvent += (sender, e) => Console.WriteLine("Event");
    // Відписатися від анонімного методу без збереження делегата не вийде
    ```
    

---

## Підсумок

1. **Events** у .NET базуються на **делегатах**, але додають механізм **підписки / відписки**, а також **інкапсулюють виклик**, обмежуючи його ззовні.
2. Рекомендовано дотримуватися патерну “відправник-аргументи”, використовуючи `EventHandler` або `EventHandler<T>`.
3. Потрібно відповідально керувати **підписками** та **відписками**, щоб не виникало витоків пам’яті.
4. Події – це важлива складова моделі “реактивної” або “подієво-орієнтованої” архітектури, яка спрощує взаємодію між об’єктами та дозволяє їм реагувати на зміни у системі.


---
> Коротко опиши різницю івенту і делегату
---

**Делегат** – це тип, що описує сигнатуру методів і дозволяє викликати один або кілька методів, не знаючи їх імен. Він виступає “вказівником на метод(и)”.

**Подія (event)** – це “обгортка” над делегатом, яка додає механізм підписки/відписки й обмежує доступ до виклику події. Зовнішній код може лише підписуватися та відписуватися від події, а викликати (ініціювати) подію може лише той об’єкт, у якому вона оголошена.

---
> Але на делегат також можна підписуватись
---

Так, делегат сам по собі також дозволяє додавати або видаляти методи (через `+=` та `-=`). Однак **основна різниця** в тому, що:

1. **Делегат** – це просто тип (вказівник на методи). Ви можете створити змінну-делегат і напряму з нею працювати: викликати її, присвоювати `null`, замінювати список методів тощо.
    
2. **Подія (event)** – це “захищений” механізм навколо делегата, який:
    
    - Дозволяє зовнішньому коду **лише** підписуватись (`+=`) і відписуватись (`-=`).
    - **Забороняє** зовнішньому коду викликати або “перевизначати” (присвоювати) цей делегат.
    - Викликати (ініціювати) подію може тільки сам клас, у якому ця подія оголошена.

Тобто подія **інкапсулює** делегат, робить підписку більш “безпечною” і передбачуваною.

>- Розкижи про event driven design

**Event-Driven Design (архітектура, керована подіями)** – це підхід до проєктування програмних систем, у якому основна взаємодія між компонентами відбувається через обробку та генерування подій. Це означає, що коли в системі відбуваються певні зміни або дії (натискання кнопок, надходження повідомлення, змінення стану об’єкта тощо), вони ініціюють події, на які реагують інші зацікавлені компоненти.

## Ключові ідеї Event-Driven Design

1. **Подієва модель (Event model)**  
    Кожен компонент може генерувати події та/або підписуватися на події, згенеровані іншими компонентами.
    
    - Компонент, який надсилає подію, зазвичай називають **відправником (publisher)**.
    - Компонент, який реагує на подію, називають **підписником (subscriber)**.
2. **Слабке зв’язування (Loose coupling)**  
    Компоненти не мусять знати про конкретні реалізації один одного. Вони просто “випромінюють” події і “слухають” події, що їх цікавлять. Це зменшує залежності між модулями й робить систему гнучкішою.
    
3. **Асинхронність та масштабованість**  
    Події можуть бути оброблені асинхронно, що особливо корисно в розподілених системах і дозволяє обробляти велике навантаження.  
    У розподіленому середовищі (наприклад, мікросервіси) події часто публікуються у брокер повідомлень (наприклад, RabbitMQ, Kafka), і сервіси-споживачі (subscribers) обробляють їх у власному темпі.
    
4. **Чітке розділення обов’язків (Separation of concerns)**  
    Компонент, який ініціює зміну, не відповідає за її обробку. Він лише сигналізує, що щось сталося. Відповідальність за обробку покладено на підписників. Таким чином, кожен компонент сфокусований на своїй конкретній ролі.
    

## Приклади застосування

1. **GUI-додатки** (клієнтські програми з інтерфейсом):
    
    - Користувач натискає кнопку (подія _Click_).
    - Інші об’єкти (наприклад, логіка контролера) підписані на цю подію та виконують потрібні дії.
2. **Реактивні системи** (stream processing):
    
    - При отриманні даних (подія “новий елемент стріму”) компоненти можуть негайно реагувати та оновлювати відповідну інформацію (UI, базу даних тощо).
3. **Мікросервіси** з брокерами повідомлень:
    
    - Один сервіс генерує подію “Замовлення створено”.
    - Інші сервіси (склад, доставка, білінг) підписані на цю подію та виконують свої задачі незалежно один від одного.
4. **IoT-системи**:
    
    - Пристрій-датчик генерує подію (наприклад, змінилася температура).
    - Підписники можуть реагувати (зберігати значення в БД, надсилати попередження, запускати додаткові процеси тощо).

## Переваги Event-Driven Design

1. **Висока гнучкість і розширюваність**  
    Додаючи нові модулі або сервіси, не потрібно змінювати вже наявні компоненти – достатньо підписати новий компонент на потрібні події.
    
2. **Асинхронність і масштабування**  
    Події можуть оброблятися паралельно чи асинхронно, що забезпечує масштабованість додатка під високими навантаженнями.
    
3. **Зменшення залежностей**  
    Відправник не знає, хто обробляє його події, і не зберігає інформації про те, як і де саме все відбувається.
    

## Недоліки та складнощі

4. **Складність відстеження потоку подій**  
    Коли система має багато взаємодій і подій, нелегко відстежити весь ланцюжок від причини до наслідку.
    
5. **Надлишкові або дубльовані обробки**  
    Потрібна чітка політика ідентифікації та фільтрування подій, щоб не виконувати одну й ту ж дію багато разів (особливо у розподілених системах із ненадійними каналами зв’язку).
    
6. **Тестування та налагодження**  
    Події можуть оброблятися в різних потоках і компонентах, що ускладнює ручне тестування та відлагодження.
    

## Підсумок

Event-Driven Design – потужна парадигма, яка дає змогу будувати системи зі слабкими зв’язками, що легко розширюються та адаптуються до змін. Головна ідея – розділення: один компонент генерує події, інші їх обробляють. Це дає високу гнучкість і зручність масштабування, але вимагає продуманого планування, чіткої структури, коректного оброблення помилок і хороших інструментів для логування та моніторингу.

>- Чи використовуються .net events у EDD

Так, **.NET events** (події в .NET) часто використовують як один із механізмів реалізації **Event-Driven Design** (EDD) у межах одного процесу або одного застосунку. Вони є “вбудованим” інструментом мови C#, що дозволяє організувати логіку, засновану на подіях (натискання кнопок, зміни стану тощо).

Однак, якщо йдеться про **велику розподілену систему**, де Event-Driven Design передбачає взаємодію між різними сервісами або мікросервісами:

1. **.NET events** стають недостатніми для міжпроцесної чи міжсервісної комунікації, оскільки вони працюють у межах одного домену застосунку (AppDomain).
2. Замість вбудованих подій часто використовують **системи повідомлень** (RabbitMQ, Kafka, Azure Service Bus тощо). Події при цьому надсилаються через брокера повідомлень, а різні сервіси на них підписуються.

Тож коротко:

- **Для локальної (внутрішньопроцесної) реалізації** EDD – .NET events справді можуть бути базовим “будівельним блоком”.
- **Для розподілених систем** – потрібні спеціалізовані засоби (message broker / event bus), але все одно логіка часто залишається “подієвою” (кожен сервіс генерує події, інші їх обробляють).