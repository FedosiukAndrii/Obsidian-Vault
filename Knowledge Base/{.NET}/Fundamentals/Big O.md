## **Big O Notation – Детальний Розбір**

Big O Notation — це математична нотація, яка використовується в інформатиці для опису складності алгоритмів. Вона дозволяє оцінити, як змінюється час виконання або використання пам’яті алгоритму залежно від розміру вхідних даних.

---

## **1. Основи Big O Notation**

Big O описує найгірший сценарій (worst-case complexity) з точки зору швидкості виконання або використання пам’яті.

### **Формальне визначення**

Нехай f(n)f(n) і g(n)g(n) — дві функції. Кажуть, що f(n)=O(g(n))f(n) = O(g(n)), якщо існують додатні сталі cc і n0n_0, такі що:

f(n)≤c⋅g(n),∀n≥n0f(n) \leq c \cdot g(n), \quad \forall n \geq n_0

Це означає, що функція f(n)f(n) асимптотично не перевищує g(n)g(n) помножену на деяку константу.

---

## **2. Поширені оцінки складності алгоритмів**

### **O(1) – Константна складність**

- Час виконання не залежить від розміру вхідних даних.
- Приклад:
    
    ```csharp
    int GetFirstElement(int[] arr) {
        return arr[0]; // Виконується за сталий час O(1)
    }
    ```
    
- Використовується, коли доступ до елемента здійснюється без додаткових обчислень (наприклад, доступ до елемента масиву за індексом).

---

### **O(log n) – Логарифмічна складність**

- Кількість операцій зростає повільно зі збільшенням вхідних даних.
- Приклад: **Бінарний пошук**
    
    ```csharp
    int BinarySearch(int[] arr, int target) {
        int left = 0, right = arr.Length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) return mid;
            if (arr[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return -1;
    }
    ```
    
- Логарифмічна складність виникає в алгоритмах, де кількість можливих варіантів скорочується в кілька разів за одну ітерацію.

---

### **O(n) – Лінійна складність**

- Час виконання зростає пропорційно розміру вхідних даних.
- Приклад: **Лінійний пошук**
    
    ```csharp
    int LinearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.Length; i++) {
            if (arr[i] == target) return i;
        }
        return -1;
    }
    ```
    
- Часто зустрічається в простих алгоритмах перебору.

---

### **O(n log n) – Лінійно-логарифмічна складність**

- Використовується в ефективних алгоритмах сортування, таких як **Merge Sort**, **Quick Sort**.
- Приклад: **Сортування злиттям**
    
    ```csharp
    void MergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            MergeSort(arr, left, mid);
            MergeSort(arr, mid + 1, right);
            Merge(arr, left, mid, right);
        }
    }
    ```
    
- Виникає, коли ми розбиваємо дані (логарифмічний фактор) і обробляємо кожну частину (лінійний фактор).

---

### **O(n²) – Квадратична складність**

- Час виконання пропорційний квадрату розміру вхідних даних.
- Приклад: **Сортування вставками**
    
    ```csharp
    void InsertionSort(int[] arr) {
        for (int i = 1; i < arr.Length; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }
    ```
    
- Виникає в алгоритмах, які мають вкладені цикли.

---

### **O(2^n) – Експоненційна складність**

- Час виконання подвоюється з кожним новим елементом вхідних даних.
- Приклад: **Рекурсивний обхід всіх підмножин**
    
    ```csharp
    void GenerateSubsets(string prefix, string str) {
        if (str.Length == 0) {
            Console.WriteLine(prefix);
            return;
        }
        GenerateSubsets(prefix + str[0], str.Substring(1));
        GenerateSubsets(prefix, str.Substring(1));
    }
    ```
    
- Використовується в задачах комбінаційного перебору.

---

### **O(n!) – Факторіальна складність**

- Найгірший рівень складності, коли кожен додатковий елемент суттєво збільшує час виконання.
- Приклад: **Знаходження всіх перестановок**
    
    ```csharp
    void Permute(char[] arr, int l, int r) {
        if (l == r) {
            Console.WriteLine(new string(arr));
        } else {
            for (int i = l; i <= r; i++) {
                Swap(ref arr[l], ref arr[i]);
                Permute(arr, l + 1, r);
                Swap(ref arr[l], ref arr[i]);
            }
        }
    }
    ```
    
- Використовується у задачах перебору всіх можливих рішень.

---

## **3. Порівняння складностей**

|Big O|Назва|Приклад алгоритму|
|---|---|---|
|O(1)|Константна|Доступ до елемента масиву|
|O(log n)|Логарифмічна|Бінарний пошук|
|O(n)|Лінійна|Лінійний пошук|
|O(n log n)|Лінійно-логарифмічна|Merge Sort, Quick Sort|
|O(n²)|Квадратична|Bubble Sort, Insertion Sort|
|O(2^n)|Експоненційна|Рекурсія в задачах підмножин|
|O(n!)|Факторіальна|Перестановки, комівояжер|

---

## **4. Як оптимізувати алгоритми?**

1. **Зменшення вкладених циклів** – часто дозволяє знизити O(n²) до O(n log n).
2. **Використання хеш-таблиць (Dictionary)** – дає O(1) доступ замість O(n).
3. **Заміна рекурсії ітеративними методами** – може допомогти уникнути O(2^n).
4. **Застосування ефективних структур даних** – наприклад, збалансованих дерев (O(log n) операції).
5. **Розбиття задачі на частини (Divide and Conquer)** – наприклад, у Quick Sort.

---

## **Висновок**

Big O Notation дозволяє порівнювати алгоритми за ефективністю та обирати оптимальні рішення. В реальних проєктах важливо не тільки оцінювати часову складність, але й враховувати використання пам’яті та архітектурні особливості системи.

---

## **Як ефективно використовувати Big O у .NET?**

Розуміння **Big O Notation** у .NET дозволяє писати **оптимізований код** та вибирати правильні структури даних та алгоритми. Це критично важливо для розробки **високонавантажених додатків**, оптимізації **бізнес-логіки**, роботи з **великими обсягами даних** та **зниження використання ресурсів**.

---

## **1. Використання ефективних структур даних у .NET**

У .NET є **колекції** (з **System.Collections**, **System.Collections.Generic**, **System.Linq**), кожна з яких має різну складність операцій.

### **Порівняння основних колекцій**

|Структура даних|Доступ O(1)O(1)|Пошук O(n)O(n)|Вставка O(n)O(n)|Видалення O(n)O(n)|
|---|---|---|---|---|
|**Array (масив)**|✅ O(1)|❌ O(n)|❌ O(n)|❌ O(n)|
|**List**|✅ O(1)|❌ O(n)|⚠️ O(n) (в середньому O(1) у кінець)|❌ O(n)|
|**LinkedList**|❌ O(n)|❌ O(n)|✅ O(1) (на початку/кінці)|✅ O(1) (за посиланням)|
|**Dictionary<K,V>**|✅ O(1) (середнє)|✅ O(1) (середнє)|✅ O(1) (середнє)|✅ O(1) (середнє)|
|**SortedList<K,V>**|❌ O(log n)|❌ O(log n)|❌ O(n)|❌ O(n)|
|**HashSet**|✅ O(1) (середнє)|✅ O(1) (середнє)|✅ O(1) (середнє)|✅ O(1) (середнє)|

### **Приклади ефективного використання**

1. **Швидкий пошук по ключу:**
    
    ```csharp
    var dictionary = new Dictionary<int, string>();
    dictionary[1] = "One";  // O(1) вставка
    var value = dictionary[1]; // O(1) доступ
    ```
    
2. **Ефективне додавання в кінець списку:**
    
    ```csharp
    var list = new List<int>();
    list.Add(10);  // O(1) амортизоване
    ```
    
3. **Вставка в будь-яке місце списку (ефективніше, ніж List):**
    
    ```csharp
    var linkedList = new LinkedList<int>();
    linkedList.AddFirst(5); // O(1)
    linkedList.AddLast(10); // O(1)
    ```
    

---

## **2. Оптимізація алгоритмів у .NET**

### **1. Логарифмічна складність: Бінарний пошук**

- Використовуйте `Array.BinarySearch` або `List<T>.BinarySearch`, щоб уникати лінійного пошуку O(n).
    
    ```csharp
    int[] arr = { 1, 3, 5, 7, 9 };
    int index = Array.BinarySearch(arr, 5); // O(log n)
    ```
    

---

### **2. Уникнення O(n²): Використання сортування O(n log n)**

.NET використовує **Timsort** (O(n log n)) для `Array.Sort()` та `List<T>.Sort()`.

```csharp
int[] arr = { 5, 2, 9, 1, 5, 6 };
Array.Sort(arr); // O(n log n)
```

> **Не використовуйте Bubble Sort чи Insertion Sort на великих даних!**

---

### **3. Використання кешування для зменшення O(2ⁿ)**

- Використовуйте **Memoization** у рекурсії.

```csharp
var cache = new Dictionary<int, int>();

int Fibonacci(int n) {
    if (n <= 1) return n;
    if (cache.ContainsKey(n)) return cache[n];

    int result = Fibonacci(n - 1) + Fibonacci(n - 2);
    cache[n] = result;
    return result;
}
```

Це зменшує складність з O(2ⁿ) до O(n).

---

## **3. Паралельна обробка великих даних**

Використовуйте **PLINQ (Parallel LINQ)** та `Parallel.ForEach`, щоб прискорити обчислення.

### **1. Використання PLINQ для зменшення O(n)**

```csharp
var numbers = Enumerable.Range(1, 1000000);
var evenNumbers = numbers.AsParallel().Where(x => x % 2 == 0).ToList();
```

- Це дозволяє паралельно обробляти великий масив, що може суттєво прискорити виконання.

---

### **2. Використання Parallel.ForEach для масивів**

```csharp
Parallel.ForEach(numbers, number => {
    Console.WriteLine(number * 2);
});
```

- Добре підходить для CPU-bound операцій.

---

## **4. Оптимізація роботи з базами даних (SQL Server)**

**Помилки при роботі з великими обсягами даних:**

4. **Використання `ToList()` перед фільтрацією**
    
    ```csharp
    var users = dbContext.Users.ToList().Where(u => u.Age > 30); // Погано: O(n)
    ```
    
    **Оптимізований варіант (відправляє фільтр у SQL Server, O(log n)):**
    
    ```csharp
    var users = dbContext.Users.Where(u => u.Age > 30).ToList(); // Краще: O(log n)
    ```
    
5. **Використання `Include()` лише при необхідності**
    
    ```csharp
    var users = dbContext.Users.Include(u => u.Orders).ToList(); // Може бути зайвим
    ```
    
6. **Індекси в SQL**
    
    - Якщо фільтрація йде по колонці `Email`, додайте індекс:
        
        ```sql
        CREATE INDEX idx_users_email ON Users(Email);
        ```
        
    - Це зменшить пошук з **O(n)** до **O(log n)**.

---

## **Висновки**

7. **Обирайте правильні структури даних**
    
    - `Dictionary<K,V>` замість `List<T>` для пошуку
    - `HashSet<T>` для унікальних значень
    - `LinkedList<T>` для швидкого вставлення
8. **Оптимізуйте алгоритми**
    
    - Використовуйте `Array.Sort()` (O(n log n)), а не `BubbleSort` (O(n²))
    - Замість лінійного пошуку використовуйте `BinarySearch()`
9. **Застосовуйте кешування (Memoization) для рекурсивних задач**
    
    - Це може зменшити складність O(2ⁿ) → O(n)
10. **Використовуйте паралельні обчислення (PLINQ, `Parallel.ForEach`)**
    
    - Це допоможе пришвидшити обробку великих даних
11. **Оптимізуйте роботу з базою даних**
    
    - `Where()` виконуйте в SQL-запиті
    - Додавайте **індекси** на часті фільтри

> **Головне правило:** **Аналізуйте алгоритми та структури даних, перш ніж код почне гальмувати у продакшені!** 🚀