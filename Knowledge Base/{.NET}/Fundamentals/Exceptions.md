Exceptions (винятки) у .NET — це механізм, що сигналізує про виникнення неочікуваних ситуацій під час виконання програми. Хоча базові знання про те, як кидати (throw) і ловити (catch) винятки, здебільшого відомі більшості розробників, для рівня Senior важливо мати глибше розуміння внутрішнього функціонування механізму винятків, усвідомлювати їх вартість, а також володіти передовими методами та шаблонами проєктування, пов’язаними з обробкою винятків.

Нижче розглядаються основні та більш просунуті аспекти винятків у .NET.

---

## 1. Типи винятків і розробка власних винятків

### 1.1. Системні винятки

В .NET Framework / .NET 6/7/… існує велика кількість винятків, що успадковуються від базового `System.Exception`. Найпоширеніші з них:

- `System.ArgumentException`, `System.ArgumentNullException`, `System.ArgumentOutOfRangeException` — порушення контракту методу через неприпустимі аргументи.
- `System.InvalidOperationException` — невідповідний стан об’єкта або середовища.
- `System.NotImplementedException` — вказує на не реалізований метод.
- `System.IO.IOException`, `SqlException` (з `System.Data.SqlClient` або аналогів) — помилки під час I/O-операцій і взаємодії з SQL Server.

### 1.2. Кастомні винятки (Custom Exceptions)

Для доменної логіки або особливих ситуацій часто доцільно створити власні винятки. Наприклад, `DomainValidationException` або `BusinessRuleViolationException`. Ключові рекомендації:

1. **Наслідувати від `Exception` або більш конкретного типу** (наприклад, від `System.ApplicationException` можна, але частіше все ж таки від `Exception`, оскільки `ApplicationException` не несе особливої функціональності).
2. **Обов’язково реалізувати конструктори**:
    
    ```csharp
    public class DomainValidationException : Exception
    {
        public DomainValidationException() { }
        public DomainValidationException(string message) : base(message) { }
        public DomainValidationException(string message, Exception inner) : base(message, inner) { }
    
        protected DomainValidationException(SerializationInfo info, StreamingContext context)
            : base(info, context) { }
    }
    ```
    
    Останній конструктор потрібен для сценаріїв серіалізації (наприклад, якщо винятки передаються між процесами в деяких системах).
3. **Додавати необхідні поля**: якщо потрібні специфічні деталі — додаткові властивості та структури даних. Це робить виняток інформативнішим.

---

## 2. Внутрішній механізм винятків та продуктивність

### 2.1. Генерація винятків — дорога операція

Незважаючи на зручність, винятки коштують системі набагато дорожче, аніж умовні перевірки. Коли викликається `throw`, CLR формує стек-трейс, що вимагає обходу кадрів стека та збору метаданих. Тому:

- **Винятки не слід використовувати для управління звичайним потоком виконання**. Вони призначені саме для аномальних сценаріїв.
- Якщо помилка передбачувана і виникає часто, краще використовувати умовні перевірки і повертати коди результату або спеціалізовані об’єкти (Result-типи або ValueTask тощо).

### 2.2. Особливості rethrow

При повторному киданні винятку важливо пам’ятати:

```csharp
catch (Exception ex)
{
    // Правильний спосіб:
    throw;
    
    // Неправильний спосіб:
    throw ex; // Перезаписує stack trace, що ускладнює відладку
}
```

`throw` без параметра зберігає оригінальний стек-трейс і дозволяє коректно зрозуміти, де саме стався виняток.

---

## 3. Exception Filters (Фільтри винятків)

Починаючи з C# 6 з’явилась можливість використовувати фільтри винятків, що дозволяють визначити логіку фільтрації ще **до** заходу в блок `catch`. Це полегшує логіку коду та усуває необхідність дублювати вміст усередині кількох `catch`.

```csharp
try
{
    // Some code
}
catch (MyCustomException ex) when (ex.Severity == SeverityLevel.Critical)
{
    // Обробляємо лише критичні помилки
}
catch (MyCustomException ex)
{
    // Обробляємо всі інші випадки MyCustomException
}
```

Це дозволяє:

- Не дублювати код обробки винятків усередині одного блоку.
- Залишити загальний `catch` для інших випадків.
- Передчасно відсіяти винятки, які ми не хочемо обробляти в даному місці.

---

## 4. Асинхронні винятки (async/await)

У випадку асинхронного коду (Task, async/await):

- Виняток, що виникає всередині методу з `async/await`, потрапляє в `Task`. Якщо ви не обробите його в `try-catch` усередині асинхронного методу, то він спливе при `await`.
- Винятки в async-методах, які не “авейтяться”, можуть бути втрачені. Тому завжди потрібно або чекати (`await`), або принаймні зберігати task та викликати на ньому `.ContinueWith(...)` для обробки помилок.

```csharp
public async Task ProcessDataAsync()
{
    try
    {
        // Якщо тут станеться виняток, catch зловить його
        await SomeFailingOperationAsync();
    }
    catch (Exception ex)
    {
        // Обробка помилки
    }
}
```

---

## 5. Глобальна обробка винятків у .NET / ASP.NET Core

### 5.1. Middleware (ASP.NET Core)

В ASP.NET Core для централізованої обробки помилок використовується Exception Handling Middleware. Це дозволяє відловити всі невловлені винятки в одному місці та налаштувати відповідь клієнту:

```csharp
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseExceptionHandler("/Error"); 
    // або свій кастомний middleware:
    // app.UseMiddleware<GlobalErrorHandlingMiddleware>();

    // Інші middleware
}
```

У своєму `GlobalErrorHandlingMiddleware` можна:

- Логувати винятки в централізованій системі (Serilog, NLog, Application Insights).
- Формувати уніфіковану структуру відповіді із кодом помилки, повідомленням, correlationId тощо.

### 5.2. Обробка винятків у фреймворках

Деякі фреймворки на зразок MassTransit, Hangfire, Worker Service, Windows Service проєкти також надають механізми глобальної обробки. Рекомендується завжди реєструвати глобальний обробник, аби жоден виняток не “вилітав” без контролю.

---

## 6. Структуроване логування та контекст

### 6.1. Збирання детальної інформації

Критично важливо, аби в логах з винятками була контекстна інформація:

- Id або назва операції, якій належав виклик (transaction id, correlation id).
- Користувач, під яким виконувалась операція.
- Ключові параметри виклику, що призвів до винятку (наприклад, `OrderId`, `CustomerId`).

Сучасні логери (Serilog, NLog, Elastic APM) дають змогу зберігати Exception як об’єкт з усіма властивостями (`ex.Message`, `ex.StackTrace`, `ex.InnerException`, `ex.Data` тощо).

### 6.2. Використання `Exception.Data`

У будь-якому винятку (зокрема і вашому кастомному) є колекція `ex.Data`:

```csharp
catch (SqlException ex)
{
    ex.Data["Query"] = currentSqlQuery;
    throw; // або логування
}
```

Це дає змогу додати додаткові поля для діагностики, особливо корисно в багаторівневих системах. При відлові/логуванні у вищих рівнях можна отримати цю інформацію та відтворити контекст виконання.

---

## 7. Кращі практики (Best Practices)

4. **Виняток = аномальна ситуація**. Не використовуйте винятки для контролю основного потоку або “легких” помилок на кшталт відсутності елементу у колекції.
5. **Конкретність винятків**. Якщо можливо, кидайте/ловіть найбільш конкретний тип винятку. Це робить код читабельнішим і дозволяє спрямовано обробляти різні ситуації.
6. **Catch, де можна відновити виконання**. У більшості випадків найкраща стратегія — відловлювати виняток там, де ви здатні його обробити або зробити fallback / реакцію. Якщо обробка неможлива, краще перекинути виняток вище.
7. **Не ковтайте винятки** (empty catch):
    
    ```csharp
    // Поганий приклад!
    catch (Exception)
    {
        // Нічого не робимо
    }
    ```
    
    Це ускладнює налагодження та може приховати критичні помилки.
8. **Логування**. При обробці винятків необхідно логувати їх з урахуванням чутливих даних (PII). Якщо застосунок обробляє дані користувача, то краще абстрагувати або замасковувати (mask) потенційно конфіденційну інформацію.
9. **Правильний rethrow**. Використовуйте `throw;` для збереження оригінального стек-трейсу.
10. **Фільтри винятків**. Користуйтеся фільтрами для кращої читабельності та ефективності коду.
11. **Custom Exception**. Розробляйте власні винятки лише в ситуаціях, де це виправдано. Тримайте в них якомога більше корисного контексту.

---

## 8. Приклади (Advanced Use Cases)

### 8.1. Глобальний хендлер у консолі / Windows Service

Для некерованих винятків (unhandled exceptions) в .NET 5+ можна підписатися на подію:

```csharp
AppDomain.CurrentDomain.UnhandledException += (sender, args) =>
{
    var ex = (Exception) args.ExceptionObject;
    // Логування, зупинка сервісу тощо
};
```

Це мінімізує вірогідність “тихого” падіння.

### 8.2. Розширене використання Exception Filters

```csharp
catch (SqlException ex) when (ex.Number == 547) // foreign key violation
{
    // specific logic for FK violation
}
```

Замість перевіряти `if (ex.Number == 547)` всередині catch-блоку, можна використати фільтр. Це підвищує читабельність і розділяє різні сценарії, що виникають із того ж типу винятків.

### 8.3. Кастомне логування з максимальною деталізацією

Якщо виняток критичний, можна збирати дані про оточення, наприклад, назву методу, де стався виняток, параметри metodu (reflection), Performance Counter дані тощо.

---

## 9. Взаємодія з SQL Server

У випадку SQL Server (`System.Data.SqlClient`, `Microsoft.Data.SqlClient`):

- Найчастіше кидається `SqlException`, яка може містити декілька помилок (`ex.Errors`).
- Коди помилок SQL Server можна порівнювати, щоб виконати певну логіку (наприклад, `ex.Number == 2601` для Duplicate Key, чи 547 для FK violation).
- Не слід забувати про транзакції: якщо виникла помилка, треба скасувати транзакцію (rollback). Це робиться, зазвичай, у тому ж `catch`.

---

## 10. Підсумки

12. **Винятки — це “контекстні” сигналізатори аномальних ситуацій**. Для високорівневого коду надзвичайно важливо зберігати максимальний контекст у винятку та правильно логувати його.
13. **Розумне використання**: Пам’ятайте про продуктивність і цілеспрямованість використання винятків.
14. **Глобальне покриття**: Завжди варто мати точку глобальної обробки винятків, щоб жодна помилка не проходила “повз” і не призводила до неконтрольованого завершення роботи.
15. **Розширені можливості**: Exception Filters, кастомні винятки з додатковими даними, асинхронна обробка помилок — усе це дає змогу робити код більш надійним, а діагностику — зручнішою.

Загалом для Senior-рівня дуже важливо правильно проектувати систему обробки винятків. Це включає ієрархію винятків, розмежування системних і доменних помилок, централізовану обробку у прикладних фреймворках (ASP.NET Core, Windows Services, мікросервіси з власними middleware) та інтеграцію з логувальними та моніторинговими інструментами для швидкого виявлення й аналізу критичних збоїв.