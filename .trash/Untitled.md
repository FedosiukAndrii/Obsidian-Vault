Асинхронність у .net async/await на рівні advanced

Reasoned for a couple of seconds

Нижче наведено детальний огляд механізму async/await у .NET на «просунутому» (advanced) рівні. Ми розглянемо не лише базові принципи, а й внутрішні аспекти, важливі нюанси використання та найпоширеніші помилки, які допускають розробники.

---

## 1. Базова ідея та створення “state machine”

### 1.1. Як компілятор трансформує async/await

Коли ми позначаємо метод ключовим словом `async` і використовуємо в ньому `await`, компілятор C# трансформує цей метод у так звану “async-стейт-машину” (async state machine). За лаштунками відбувається таке:

1. **Розділення методу на кілька частин**:
    - Усі вирази “до” першого `await`
    - Усі вирази “після” першого `await` і “до” наступного `await`
    - і так далі…
2. **Збереження проміжних станів**:
    - Всі змінні, які можуть бути використані “до” та “після” `await`, зберігаються у спеціальному об’єкті-стані (state object).
    - Цей об’єкт зберігає також індекс або “номер” стану, щоб у потрібний момент відновити виконання з місця зупинки.
3. **Створення callback-ів**:
    - Коли викликається `await someTask`, компілятор генерує код, що підписується на завершення `someTask` (через метод `Task.ContinueWith()` або через внутрішні механізми, залежно від .NET версії). Після завершення — виконується наступний “стан” (код після `await`).

Отже, `async/await` — це лише “цукор” (syntactic sugar) над патерном колбеків, який спрощує написання асинхронного коду.

### 1.2. Task проти ValueTask

- `Task`: стандартний тип, який використовується при поверненні асинхронних операцій без результату (`Task`) або з результатом (`Task<T>`).
- `ValueTask`: з’явився починаючи з .NET Core 2.0. Дозволяє уникнути додаткового алокаційного навантаження у випадках, коли результат вже доступний синхронно (наприклад, кешовані дані).
    - Проте, використання `ValueTask` складніше й накладає обмеження (не можна повторно викликати `await` на одному й тому ж `ValueTask`, за винятком правил, зазначених в документації).
    - Рекомендується використовувати `ValueTask` лише у високонавантажених сценаріях або у бібліотеках, де контроль над життєвим циклом задач є критичним. Для загального використання `Task` лишається кращим вибором.

---

## 2. Синхронізація та контексти виконання

### 2.1. SynchronizationContext і TaskScheduler

За замовчуванням, коли ви викликаєте `await someTask` в UI-потоках (WPF, WinForms, ASP.NET WebForms), середовище виклику може мати спеціальний `SynchronizationContext`, що визначає, куди саме “повертатись” після завершення асинхронної операції.

- Наприклад, у UI-додатках повернення відбувається в основний UI-потік.
- У ASP.NET Core застосунках (починаючи з .NET 6) зазвичай використовується пул потоків (Thread Pool), але за потреби його можна налаштувати по-іншому.

### 2.2. ConfigureAwait

Метод `ConfigureAwait(bool continueOnCapturedContext)` визначає, чи потрібно “повертатись” до вихідного `SynchronizationContext`.

- За замовчуванням (`await task` без вказівки `ConfigureAwait`) ми переходимо у captured context (як правило, це UI-потік або потік пулу, залежно від середовища).
- Якщо ми викличемо `await task.ConfigureAwait(false)`, продовження буде виконуватись у будь-якому доступному потоці з пулу (Thread Pool), не повертаючись у вихідний контекст.

В ASP.NET Core, починаючи з .NET 5+, рекомендується **завжди** використовувати `ConfigureAwait(false)` у бібліотеках, а у верхньому рівні UI/UI-логіки — можна опускати. Таким чином ми уникаємо непотрібного перемикання контекстів.

---

## 3. Управління потоками та “холості” блокування

### 3.1. Синхронний блокуючий виклик .Result / .GetAwaiter().GetResult()

Однією з найпоширеніших помилок є виклик `task.Result` або `task.GetAwaiter().GetResult()` в середовищі, де вже є `SynchronizationContext`, особливо в UI-потоці або в ASP.NET (до .NET Core). Це може призвести до взаємного блокування (deadlock). Наприклад:

csharp

КопироватьРедактировать

`// Умовний приклад у WinForms/WPF/ASP.NET (синхронний контекст): public ActionResult SomeAction() {     // викликаємо асинхронний метод, але чекаємо синхронно     var data = GetDataAsync().Result; // <-- потенційний deadlock     return View(data); }`

Тому, **кращою практикою** є “піднімати” async аж до найвищого рівня:

csharp

КопироватьРедактировать

`public async Task<ActionResult> SomeAction() {     var data = await GetDataAsync();     return View(data); }`

### 3.2. Thread Pool starvation

У .NET є пул потоків (Thread Pool), який за замовчуванням обслуговує виконання Task’ів. Коли ми блокуємо потік з пулу синхронним викликом `.Result`, інші асинхронні операції можуть чекати звільнення потоків, тому що пул буде вичерпано блокуванням. У сучасних версіях .NET пул потоків розширюється динамічно, але це все одно погано впливає на продуктивність.

---

## 4. Винятки та обробка помилок в async/await

### 4.1. Приклад обробки винятків

В асинхронних методах усі винятки “загортаються” у `Task`. Тобто коли виникає помилка в асинхронному методі:

csharp

КопироватьРедактировать

`public async Task DoWorkAsync() {     throw new InvalidOperationException("Помилка!"); }`

– виняток буде кинутий не відразу, а в момент, коли відбувається `await DoWorkAsync()`. Тому:

csharp

КопироватьРедактировать

`try {     await DoWorkAsync(); } catch (InvalidOperationException ex) {     // Ловимо виняток тут }`

### 4.2. UnobservedTaskException

Якщо асинхронна операція завершується з помилкою, але ніхто не виконав `await` або `.Wait()/.Result`, виняток стає “непоміченим” (unobserved). У .NET Framework такі винятки можуть “спливати” в додатку та зупиняти його роботу (залежно від налаштувань). У .NET Core/5/6 і далі непомічений виняток викликає подію `TaskScheduler.UnobservedTaskException`, але, як правило, це не “валить” процес. Проте це вважається поганою практикою — завжди завершуйте задачі `await`-ом або хоча б `.ContinueWith(...)`, щоб обробити винятки.

---

## 5. Паралельність і конкурентність

### 5.1. Паралельне виконання декількох задач

Асинхронність не обов’язково означає “багатопоточність” чи “паралельне” виконання. Коли ви пишете:

csharp

КопироватьРедактировать

`await Task1(); await Task2();`

…друга задача виконується **після** першої, послідовно. Якщо потрібно виконувати обидві в “паралель”, то краще робити:

csharp

КопироватьРедактировать

`var task1 = Task1(); var task2 = Task2();  // Виконуються водночас. Чекаємо обидві. await Task.WhenAll(task1, task2);`

### 5.2. ValueTask та паралельність

При використанні `ValueTask` слід бути дуже уважним, оскільки повторне очікування (await) того ж примірника `ValueTask` може призвести до непередбачуваних результатів. Якщо необхідно виконувати одну і ту ж операцію багато разів, краще створювати новий `ValueTask` (тобто викликати метод з `async` оператором знову) або використовувати `Task`.

---

## 6. Async Streams (IAsyncEnumerable)

### 6.1. Навіщо потрібні асинхронні потоки

Починаючи з C# 8, з’явився новий синтаксис для роботи зі стрімами асинхронних даних:

csharp

КопироватьРедактировать

`public async IAsyncEnumerable<int> GetNumbersAsync() {     for (int i = 0; i < 10; i++)     {         await Task.Delay(100);         yield return i;     } }`

- Тип повернення: `IAsyncEnumerable<T>`
- Ключове слово: `await foreach (var number in GetNumbersAsync()) {...}`

Це дає змогу асинхронно отримувати послідовність даних, не завантажуючи все у пам’ять за один раз (важливо для стрімів, великих наборів даних тощо).

### 6.2. Підводні камені

4. Кожен виклик `await foreach` (тобто один цикл “оберту”) насправді робить асинхронну операцію: можливо, з мережею, файлом тощо.
5. Винятки, як і раніше, спливають у місці виклику. Тобто якщо помилка станеться під час `MoveNextAsync()`, вона буде вилітати в `await foreach` конструкції.

---

## 7. CancellationToken і скасування асинхронних операцій

### 7.1. Передача токену

Більшість .NET API, що підтримує async, надає перевантаження з `CancellationToken`. Правильне використання виглядає так:

csharp

КопироватьРедактировать

`public async Task GetDataAsync(CancellationToken cancellationToken = default) {     // ... асинхронна логіка     // перевірка чи відмінено     cancellationToken.ThrowIfCancellationRequested();          await someTask;          // якщо ви викликаєте інші асинхронні методи, що підтримують токен, передавайте його:     await AnotherOperationAsync(cancellationToken); }`

У разі, якщо токен скасовано, метод викине виняток `OperationCanceledException`.

### 7.2. Об’єднання токенів

Якщо є декілька джерел скасування (наприклад, таймаут, натискання кнопки “Відмінити”, завершення веб-запиту), іноді треба об’єднати декілька `CancellationToken` в один. Для цього існує `CancellationTokenSource.CreateLinkedTokenSource(...)`.

---

## 8. Кращі практики та типові помилки

6. **Уникайте `.Result`, `.Wait()`**, якщо це не екстрено необхідно і ви точно знаєте, що не відбудеться блокування потоку. Найкраще — писати повністю асинхронний ланцюжок викликів.
7. **Не забувайте викликати `ConfigureAwait(false)`** у бібліотеках та “внутрішньому” коді, щоб уникнути зайвого перемикання контексту й підвищити продуктивність.
8. **Переконайтеся, що обробляєте винятки** (для асинхронних методів — обробка повинна бути там, де виконується `await`).
9. **Не створюйте надто багато дрібних тасків** (наприклад, у циклі на 1 000 000 елементів не кожну ітерацію виконувати `await Task.Run(...)`). Це створить величезний overhead у вигляді створення тасків. Замість цього — розбийте навантаження на крупніші сегменти або використовуйте інші методи, наприклад `Parallel.ForEach`.
10. **Звертайте увагу на лімітовані ресурси** при паралельному виклику (наприклад, виклики до бази даних). Якщо ви робите `Task.WhenAll(...)` для тисячі операцій, це може перевантажити сервер. Інколи треба впровадити SemaphoreSlim або подібний механізм ліміту.
11. **Використовуйте профайлинг та логування**. Високонавантажені асинхронні додатки можуть виникати проблеми з “thread pool starvation” чи надмірною конкуренцією, тому важливо моніторити (Performance Counter, EventSource, DiagnosticSource тощо).

---

## 9. Підсумок

Асинхронність в .NET за допомогою ключових слів `async/await` — це високорівневий синтаксичний цукор над генерацією callback’ів та state machine, що значно спрощує написання асинхронного коду у порівнянні з “ручними” підходами (`BeginInvoke/EndInvoke`, `ContinueWith` тощо). Проте, як і з усіма потужними інструментами, є “підводні камені”:

- Потенційні deadlock’и при неправильному виклику `.Result`
- Надмірне перемикання контекстів без `ConfigureAwait(false)`
- UnobservedTaskException, якщо не “дочекатися” завершення Task
- Ресурсові або паралельні обмеження, якщо виконувати занадто багато асинхронних завдань

Для ефективного використання async/await важливо розуміти “внутрішню кухню” (state machine), відслідковувати обробку винятків та управління контекстом виконання. Також варто пам’ятати, що асинхронність — це не обов’язково паралельність. Якщо необхідна саме паралельна робота, доведеться застосовувати додаткові механізми (Task.WhenAll, Parallel LINQ або інші засоби).

При дотриманні всіх кращих практик, асинхронний код у .NET допомагає масштабувати додаток на велику кількість одночасних операцій, роблячи його більш чуйним і ефективним.

o1

##### Вы сказали:

Різниця між result / getawaiter.getresult

Reasoned for 5 seconds

Якщо коротко, **обидва виклики**—`task.Result` і `task.GetAwaiter().GetResult()`—зупиняють поточний потік, доки `Task` не виконається, **але**:

12. **`task.Result`**
    
    - Повертає результат роботи задачі (якщо це `Task<T>`).
    - У разі винятку (exception), він **загортається** в `AggregateException`, і вам доведеться діставати “справжню” помилку через `ex.InnerException` (де `ex` — це `AggregateException`).
13. **`task.GetAwaiter().GetResult()`**
    
    - Аналогічно блокує потік, доки задача не виконається, але не використовує `AggregateException`.
    - Якщо всередині задачі виникне виняток, він **буде перекинутий напряму**, без загортання в `AggregateException`. Тобто ви отримаєте “оригінальний” exception.

Істотна різниця — **у типі винятків**:

- `task.Result` => викидає `AggregateException`
- `task.GetAwaiter().GetResult()` => викидає “справжній” виняток (наприклад, `InvalidOperationException` і т.ін.)

Ось приклад для ілюстрації:

csharp

КопироватьРедактировать

`Task<int> task = Task.Run(() => throw new InvalidOperationException("Помилка"));  try {     // Випаде AggregateException із InnerException = InvalidOperationException     var r = task.Result;  } catch (AggregateException aex) {     var realException = aex.InnerException; // Тут буде InvalidOperationException }  try {     // Викине безпосередньо InvalidOperationException     var r2 = task.GetAwaiter().GetResult(); } catch (InvalidOperationException ex) {     // Ловимо "справжній" виняток одразу }`

> У **реальному** асинхронному коді (де ви можете використовувати `await`) майже завжди **краще уникати** обох підходів і повертати `Task`, щоб дозволити “природний” `await`. А ось якщо вам **справді** потрібно отримати результат синхронно (і ви впевнені, що не викличете “deadlock”), то `GetAwaiter().GetResult()` надає оригінальний виняток і точніший stack trace.

Що стосується впливу на блокування потоків, то **і `Result`, і `GetAwaiter().GetResult()` блокують** потік на завершення задачі. Для асинхронного/серверного коду це може стати джерелом `deadlock`-ів або негативно вплинути на продуктивність (thread pool starvation). Тому бажано “піднімати” асинхронність угору (теж саме “async all the way”) і використовувати `await`.

o1

##### Вы сказали:

CancelationToken. Як правильно користуватись cancelationtoken, при скасуванні виклику api.

Reasoned for 6 seconds

Нижче наведено рекомендації та кращі практики щодо того, **як використовувати `CancellationToken`** для скасування викликів (зокрема HTTP-запитів або API-методів) у .NET. Приклади орієнтовані в основному на ASP.NET Core, але загальні підходи справедливі й для інших середовищ.

---

## 1. Загальний принцип роботи `CancellationToken`

14. **`CancellationToken`** — це структура, яка сигналізує, що певна операція має бути перервана.
15. **`CancellationTokenSource`** — “джерело” токена, яке в будь-який момент може викликати `.Cancel()`, і тим самим перевести пов’язаний `CancellationToken` у стан “запит на скасування”.

У контексті викликів HTTP/API:

- Якщо ви **клієнт** (наприклад, викликаєте зовнішнє API через `HttpClient`), ви можете створити або передати існуючий `CancellationToken`, щоб при надходженні сигналу скасування перервати виконання запиту.
- Якщо ви **сервер** (написали свій API в ASP.NET Core), ви можете отримати `CancellationToken` (наприклад, із параметра методу контролера чи з `HttpContext.RequestAborted`) і передати його в інші операції, що виконуються усередині вашого API-методу.

---

## 2. Скасування HTTP-запиту на боці клієнта

### 2.1. Приклад з `HttpClient`

csharp

КопироватьРедактировать

`public async Task<string> CallExternalApiAsync(string url, CancellationToken cancellationToken) {     using var client = new HttpClient();          // Передаємо cancellationToken у метод, щоб можна було скасувати запит     HttpResponseMessage response = await client.GetAsync(url, cancellationToken);          // Якщо тут юзер/код викликали Cancel(), то операція перерветься з винятком OperationCanceledException          response.EnsureSuccessStatusCode();     return await response.Content.ReadAsStringAsync(cancellationToken); }`

- Якщо вам потрібно явно скасувати, ви створюєте `CancellationTokenSource cts = new CancellationTokenSource();`, передаєте `cts.Token` у `CallExternalApiAsync(...)`, а згодом (наприклад, за умови таймауту або натискання кнопки “Відміна”) викликаєте `cts.Cancel()`.

### 2.2. Таймаут як варіант скасування

csharp

КопироватьРедактировать

`using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5)); try {     string result = await CallExternalApiAsync("https://example.com", cts.Token); } catch (OperationCanceledException) {     // Логіка обробки відміни чи таймауту }`

Тут через 5 секунд виклик `cts.Cancel()` відбудеться автоматично, і метод `CallExternalApiAsync` перерве виконання.

---

## 3. Скасування на боці сервера (ASP.NET Core)

### 3.1. Використання токена запиту

В ASP.NET Core у кожного запиту є властивість `HttpContext.RequestAborted`—це `CancellationToken`, який спрацьовує, якщо клієнт розірвав з’єднання або викликав відміну. Тобто, коли браузер/клієнт обриває запит, `RequestAborted` переходить у стан “скасування”.

csharp

КопироватьРедактировать

`[HttpGet] public async Task<IActionResult> GetData(CancellationToken cancellationToken) {     // ASP.NET Core автоматично передає токен в параметр "cancellationToken",      // який фактично == HttpContext.RequestAborted     // (Якщо методу потрібні різні токени, можна явно використати HttpContext.RequestAborted)      // Передамо цей токен далі в якусь внутрішню операцію:     var data = await _myService.GetSomeDataAsync(cancellationToken);          return Ok(data); }`

Альтернатива (до того ж самого):

csharp

КопироватьРедактировать

`[HttpGet] public async Task<IActionResult> GetData() {     var cancellationToken = HttpContext.RequestAborted;     var data = await _myService.GetSomeDataAsync(cancellationToken);     return Ok(data); }`

- Якщо клієнт закрив сторінку / розірвав з’єднання, у вашому коді (де ви виконуєте `await`) виникне `OperationCanceledException`, якщо методи “всередині” поважають токен і регулярно перевіряють `cancellationToken.ThrowIfCancellationRequested()` (або мають його як параметр в асинхронних викликах).

### 3.2. Приклади внутрішнього використання в методах

csharp

КопироватьРедактировать

`public async Task<List<string>> GetSomeDataAsync(CancellationToken cancellationToken) {     // Регулярно перевіряйте:     cancellationToken.ThrowIfCancellationRequested();          // Припустимо, викликаємо зовнішнє API     using var httpClient = new HttpClient();     var response = await httpClient.GetAsync("https://...", cancellationToken);          // Знову перевірка (необов’язкова, але буває корисна між важливими операціями)     cancellationToken.ThrowIfCancellationRequested();      response.EnsureSuccessStatusCode();     var json = await response.Content.ReadAsStringAsync(cancellationToken);     return JsonConvert.DeserializeObject<List<string>>(json); }`

Як тільки клієнт (або інша причина) спричинить відміну `HttpContext.RequestAborted`, `OperationCanceledException` вилетить у найближчому асинхронному виклику, де враховується цей токен.

---

## 4. Ключові моменти при скасуванні

16. **Перевірка `IsCancellationRequested` чи `ThrowIfCancellationRequested()`**
    
    - Щоб операція могла коректно “припинитися” в середині довгої задачі (наприклад, в циклі чи при обробці великих даних), варто час від часу явно перевіряти токен:
        
        csharp
        
        КопироватьРедактировать
        
        `for (int i = 0; i < bigCount; i++) {     cancellationToken.ThrowIfCancellationRequested();     // або     if (cancellationToken.IsCancellationRequested)     {         // зробити прибирання і вийти     }          // обробляємо елемент... }`
        
    - Для методів, що приймають `CancellationToken` (наприклад, `HttpClient.GetAsync(url, cancellationToken)`), фреймворк сам “знає”, коли кинути `OperationCanceledException`.
17. **Обробка `OperationCanceledException`**
    
    - Зазвичай це робиться на рівні вищого виклику або в середині методу, щоб правильно “відкотити” часткові зміни чи виконати додаткову логіку (логування, чистка ресурсів тощо).
18. **Ніколи не ковтайте `OperationCanceledException` “тихенько”**
    
    - Якщо ви зловили `OperationCanceledException`, зазвичай треба або:
        - Перевикинути її далі (`throw;`), або
        - Коректно завершити метод, повідомивши “глобально”, що операцію скасовано (наприклад, повернути `Task.CompletedTask` чи спеціальний результат).
    - Ігнорування відміни може призвести до непередбачуваної поведінки.
19. **Використання `CancellationTokenSource.CreateLinkedTokenSource(...)`**
    
    - Якщо у вас є **декілька джерел скасування** (наприклад, HTTP-запит і таймер), можна створити “об’єднаний” токен, який скасовуватиметься при спрацьовуванні будь-якого з джерел:
        
        csharp
        
        КопироватьРедактировать
        
        `using var ctsGlobal = new CancellationTokenSource(); using var ctsTimeout = new CancellationTokenSource(TimeSpan.FromSeconds(10)); using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(     ctsGlobal.Token,      ctsTimeout.Token,      HttpContext.RequestAborted );  await _someLongOperation.ExecuteAsync(linkedCts.Token);`
        
    - Як тільки один із токенів буде скасовано, `linkedCts.Token` теж стане скасованим.

---

## 5. Поради та поширені помилки

20. **Передавати `CancellationToken` угору по викликах**
    
    - Усі методи, що можуть тривати довго або викликають інші асинхронні операції, мають приймати і використовувати переданий токен.
21. **Не ігнорувати `OperationCanceledException`**
    
    - Якщо скасування — це нормальний сценарій (користувач натиснув “Stop”, запит закрився тощо), просто дайте винятку “пройти” далі, щоб ASP.NET Core чи ваш клієнт його коректно обробив.
22. **Уважно ставитися до ресурсів**
    
    - Якщо операція перервана, але перед цим ви відкрили з’єднання з БД чи файл — переконайтесь, що ви закриваєте ресурси, наприклад у `finally` блоці чи через `using`.
23. **Перевіряти поведінку повторних викликів**
    
    - Якщо ви використовуєте `HttpClientFactory` (рекомендовано в ASP.NET Core), переконайтеся, що ви передаєте токен у методи `.GetAsync(...)`, `.PostAsync(...)` тощо. Тоді запит справді перерветься.
24. **У UI-додатках** (WPF, WinForms) логіка скасування аналогічна, але ви зазвичай “прив’язуєте” відміну до кнопки “Відмінити” чи “Скасувати”.
    

---

## 6. Підсумок

При скасуванні виклику API (чи то ви **клієнт**, чи то **сервер**), **основний принцип** — **передайте `CancellationToken` у всі асинхронні операції** і реагуйте на `OperationCanceledException`. Це дозволяє:

- Економити ресурси (не чекати даремно виконання запиту, якщо користувач/клієнт вже не зацікавлений у відповіді).
- Покращити користувацький досвід (миттєво зупиняти тривалі операції).
- Писати чистий і передбачуваний код (асинхронні операції вміють самі “виходити”, коли отримують сигнал відміни).

Таким чином, при **правильному поширенні `CancellationToken`** і обробці відміни, ваш API або клієнтський код зможуть коректно припиняти довготривалі чи непотрібні операції.

o1

##### Вы сказали:

Що таке canselationtokensource

Reasoned for a few seconds

**`CancellationTokenSource`** – це клас (джерело скасування), який керує життєвим циклом об’єкта `CancellationToken`. Коли ви створюєте `CancellationTokenSource`, він генерує пов’язаний `CancellationToken` (через властивість `Token`). Надалі, якщо потрібно повідомити про скасування операції (за запитом користувача, при вичерпанні часу тощо), достатньо викликати метод `Cancel()` у `CancellationTokenSource`. Тоді всі операції, які використовують цей токен, отримають сигнал про відміну та зможуть коректно припинити виконання.

### Як це виглядає в коді

25. **Створення джерела**:
    
    csharp
    
    КопироватьРедактировать
    
    `var cts = new CancellationTokenSource(); CancellationToken token = cts.Token;`
    
26. **Передача токена в асинхронний метод**:
    
    csharp
    
    КопироватьРедактировать
    
    `var task = SomeLongOperationAsync(token);`
    
27. **Виклик скасування**:
    
    csharp
    
    КопироватьРедактировать
    
    `// Коли потрібно перервати cts.Cancel();`
    
28. **Обробка скасування всередині методу**:
    
    csharp
    
    КопироватьРедактировать
    
    `public async Task SomeLongOperationAsync(CancellationToken cancellationToken) {     for (int i = 0; i < 1000; i++)     {         cancellationToken.ThrowIfCancellationRequested();         // виконання якоїсь логіки...         await Task.Delay(10);     } }`
    

Як тільки викликається `cts.Cancel()`, виконується сигнал “Скасовано” в `token`. Якщо методи чи цикли перевіряють цей токен (наприклад, через `ThrowIfCancellationRequested()`), вони миттєво отримають виняток `OperationCanceledException` або зможуть іншим чином зупинитись. Це допомагає грамотно і своєчасно завершити асинхронну операцію, не витрачаючи зайвих ресурсів.

o1

##### Вы сказали:

Що якщо визивати await на одну й тий самй обʼєкт більше одного разу

Reasoned for 11 seconds

Коротка відповідь: **для `Task` повторний `await` дасть той самий результат (або викличе той самий виняток), а от із `ValueTask` потрібно бути обережнішим** — він не призначений для багаторазового очікування (repeat-await) без додаткових кроків.

Нижче детальні пояснення:

---

## 1. Повторний `await` на одному й тому ж `Task`

### 1.1. Повторні очікування вже виконаного `Task`

Якщо у вас є змінна типу `Task<T>` і вона **вже завершилась** (успішно чи з винятком), то повторний `await`:

29. **У разі успіху** (Task в стані `RanToCompletion`):
    
    - Поверне той самий результат, який задача вже обчислила. Задача “не перезапускається”.
30. **У разі помилки** (Task в стані `Faulted`):
    
    - Повторний `await` знову згенерує той самий виняток. Тобто, один і той самий `Task` “запам’ятовує” виняток.
31. **У разі відміни** (Task в стані `Canceled`):
    
    - Повторний `await` знову згенерує `OperationCanceledException`.

З точки зору **виконання** коду в самій асинхронній операції, вона відпрацювала лише **один раз**. Але при “дочікуванні” (await) повторно ви отримуєте її зафіксований результат (чи виняток).

### 1.2. Повторні очікування під час виконання

Якщо кілька частин коду “одночасно” роблять `await` на один і той самий `Task` (який ще не завершився), то вони **всі дочекаються одного результату**:

csharp

КопироватьРедактировать

`var task = SomeAsyncOperation(); // Повертає Task<int>  int a = await task;     // Перший await int b = await task;     // Другий await`

- За фактом, операція `SomeAsyncOperation()` запуститься один раз.
- Обидва `a` і `b` будуть однаковими.
- Якщо виникне виняток, обидва `await` його отримають.

У такій ситуації немає повторного запуску коду. Це просто “шеринг” одного виконання задачі з кількома “споживачами” результату.

---

## 2. Повторний `await` на одному й тому ж `ValueTask`

З `ValueTask` ситуація складніша. За **офіційною документацією** Microsoft, **`ValueTask` (без додаткових перетворень) не підтримує повторне очікування**. Якщо вам треба “дочекатися” результату кілька разів або передати `ValueTask` кудись у довгий ланцюг викликів, бажано викликати `.AsTask()` і далі оперувати звичайним `Task`.

### 2.1. Чому так?

`ValueTask` оптимізовано для сценаріїв, де:

- Операція може часто завершуватися **синхронно** (наприклад, значення вже кешоване, і немає сенсу створювати зайвий об’єкт `Task`).
- Операція завершується одноразово, і результат “споживається” відразу.

Але якщо ви вдруге виконаєте `await` на **тому ж самому** екземплярі `ValueTask`, це може призвести до некоректної поведінки або винятків. Документація прямо вказує: **“A `ValueTask` may only be awaited once.”**

### 2.2. Як обійти

Якщо вам потрібно передавати результат або повторно чекати, застосуйте:

csharp

КопироватьРедактировать

`ValueTask<int> valueTask = SomeValueTaskOperation(); Task<int> standardTask = valueTask.AsTask();  int result1 = await standardTask; int result2 = await standardTask;`

У цьому випадку `AsTask()` створить (або поверне кешований) `Task`, який уже дозволено чекати багато разів.

---

## 3. Чи запускається асинхронна операція заново?

Ні. У .NET **`Task` і `ValueTask` — це одноразове виконання**. Якщо воно вже завершилося, повторний `await` повертає “закешований” результат/виняток. Немає механізму “перезапуску”:

- Якщо треба виконати операцію знову — треба **заново** викликати метод, який повертає новий `Task` або новий `ValueTask`.
- Якщо ж треба розшарити (reuse) той самий результат, можна просто зберігати посилання на завершений `Task` і `await`-ити його в різних місцях.

---

## 4. Загальні рекомендації

32. **Нормальна практика** – мати один виклик асинхронного методу (`methodAsync()`) і “розшарювати” результат, якщо цього вимагає логіка. Це автоматично означає, що один і той самий `Task` можуть `await`-ити декілька разів.
33. **З `ValueTask`** будьте особливо уважні. Якщо треба повторно `await` чи передавати результат у глибину, використовуйте `AsTask()`.
34. **Не плутайте** кілька “await” на **одному `Task`** із кількома викликами **одного асинхронного методу**. Кожен виклик методу створює **нову** задачу.

---

### Висновок

- **`Task`:** можна `await`-ити скільки завгодно разів (одночасно чи послідовно). Якщо задача ще виконується, всі чекають один результат; якщо вже завершилася, повертається кешований результат/виняток.
- **`ValueTask`:** за задумом **одноразовий** для очікування. При потребі повторного очікування перетворюйте його на `Task` викликом `.AsTask()`.
- **Повторний `await` не перезапускає** операцію, а просто отримує (або повторно “кидає”) її закінчений стан.